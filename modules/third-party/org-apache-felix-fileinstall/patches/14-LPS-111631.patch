diff --git a/org/apache/felix/utils/properties/ConfigurationHandler.java b/org/apache/felix/utils/properties/ConfigurationHandler.java
index c7d4277..fc3175b 100644
--- a/org/apache/felix/utils/properties/ConfigurationHandler.java
+++ b/org/apache/felix/utils/properties/ConfigurationHandler.java
@@ -16,8 +16,8 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.apache.felix.utils.properties;
 
+package org.apache.felix.utils.properties;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
@@ -30,7 +30,9 @@ import java.io.PushbackReader;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.io.Writer;
+
 import java.lang.reflect.Array;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
@@ -44,11 +46,10 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
-
 /**
  * The <code>ConfigurationHandler</code> class implements configuration reading
- * form a <code>java.io.InputStream</code> and writing to a
- * <code>java.io.OutputStream</code> on behalf of the
+ * form a <code>InputStream</code> and writing to a
+ * <code>OutputStream</code> on behalf of the
  * {@link FilePersistenceManager} class.
  *
  * <pre>
@@ -56,873 +57,954 @@ import java.util.Map;
  *  prop = symbolic-name . // 1.4.2 of OSGi Core Specification
  *  symbolic-name = token { &quot;.&quot; token } .
  *  token = { [ 0..9 ] | [ a..z ] | [ A..Z ] | '_' | '-' } .
- *  value = [ type ] ( &quot;[&quot; values &quot;]&quot; | &quot;(&quot; values &quot;)&quot; | simple ) .
+ *  value = [ type ] (&quot;[&quot; values &quot;]&quot; | &quot;(&quot; values &quot;)&quot; | simple) .
  *  values = simple { &quot;,&quot; simple } .
  *  simple = &quot;&quot;&quot; stringsimple &quot;&quot;&quot; .
  *  type = // 1-char type code .
  *  stringsimple = // quoted string representation of the value .
  * </pre>
  */
-public class ConfigurationHandler
-{
-    protected static final String ENCODING = "UTF-8";
-
-    protected static final int TOKEN_NAME = 'N';
-    protected static final int TOKEN_EQ = '=';
-    protected static final int TOKEN_ARR_OPEN = '[';
-    protected static final int TOKEN_ARR_CLOS = ']';
-    protected static final int TOKEN_VEC_OPEN = '(';
-    protected static final int TOKEN_VEC_CLOS = ')';
-    protected static final int TOKEN_COMMA = ',';
-    protected static final int TOKEN_VAL_OPEN = '"'; // '{';
-    protected static final int TOKEN_VAL_CLOS = '"'; // '}';
-    protected static final int TOKEN_SPACE = ' ';
-
-    protected static final int TOKEN_COMMENT = '#';
-
-    // simple types (string & primitive wrappers)
-    protected static final int TOKEN_SIMPLE_STRING = 'T';
-    protected static final int TOKEN_SIMPLE_INTEGER = 'I';
-    protected static final int TOKEN_SIMPLE_LONG = 'L';
-    protected static final int TOKEN_SIMPLE_FLOAT = 'F';
-    protected static final int TOKEN_SIMPLE_DOUBLE = 'D';
-    protected static final int TOKEN_SIMPLE_BYTE = 'X';
-    protected static final int TOKEN_SIMPLE_SHORT = 'S';
-    protected static final int TOKEN_SIMPLE_CHARACTER = 'C';
-    protected static final int TOKEN_SIMPLE_BOOLEAN = 'B';
-
-    // primitives
-    protected static final int TOKEN_PRIMITIVE_INT = 'i';
-    protected static final int TOKEN_PRIMITIVE_LONG = 'l';
-    protected static final int TOKEN_PRIMITIVE_FLOAT = 'f';
-    protected static final int TOKEN_PRIMITIVE_DOUBLE = 'd';
-    protected static final int TOKEN_PRIMITIVE_BYTE = 'x';
-    protected static final int TOKEN_PRIMITIVE_SHORT = 's';
-    protected static final int TOKEN_PRIMITIVE_CHAR = 'c';
-    protected static final int TOKEN_PRIMITIVE_BOOLEAN = 'b';
-
-    protected static final String CRLF = "\r\n";
-    protected static final String INDENT = "  ";
-    protected static final String COLLECTION_LINE_BREAK = " \\\r\n";
-
-    protected static final Map code2Type;
-    protected static final Map type2Code;
-
-    // set of valid characters for "symblic-name"
-    private static final BitSet NAME_CHARS;
-    private static final BitSet TOKEN_CHARS;
-
-    static
-    {
-        type2Code = new HashMap();
-
-        // simple (exclusive String whose type code is not written)
-        type2Code.put( Integer.class, new Integer( TOKEN_SIMPLE_INTEGER ) );
-        type2Code.put( Long.class, new Integer( TOKEN_SIMPLE_LONG ) );
-        type2Code.put( Float.class, new Integer( TOKEN_SIMPLE_FLOAT ) );
-        type2Code.put( Double.class, new Integer( TOKEN_SIMPLE_DOUBLE ) );
-        type2Code.put( Byte.class, new Integer( TOKEN_SIMPLE_BYTE ) );
-        type2Code.put( Short.class, new Integer( TOKEN_SIMPLE_SHORT ) );
-        type2Code.put( Character.class, new Integer( TOKEN_SIMPLE_CHARACTER ) );
-        type2Code.put( Boolean.class, new Integer( TOKEN_SIMPLE_BOOLEAN ) );
-
-        // primitives
-        type2Code.put( Integer.TYPE, new Integer( TOKEN_PRIMITIVE_INT ) );
-        type2Code.put( Long.TYPE, new Integer( TOKEN_PRIMITIVE_LONG ) );
-        type2Code.put( Float.TYPE, new Integer( TOKEN_PRIMITIVE_FLOAT ) );
-        type2Code.put( Double.TYPE, new Integer( TOKEN_PRIMITIVE_DOUBLE ) );
-        type2Code.put( Byte.TYPE, new Integer( TOKEN_PRIMITIVE_BYTE ) );
-        type2Code.put( Short.TYPE, new Integer( TOKEN_PRIMITIVE_SHORT ) );
-        type2Code.put( Character.TYPE, new Integer( TOKEN_PRIMITIVE_CHAR ) );
-        type2Code.put( Boolean.TYPE, new Integer( TOKEN_PRIMITIVE_BOOLEAN ) );
-
-        // reverse map to map type codes to classes, string class mapping
-        // to be added manually, as the string type code is not written and
-        // hence not included in the type2Code map
-        code2Type = new HashMap();
-        for ( Iterator ti = type2Code.entrySet().iterator(); ti.hasNext(); )
-        {
-            Map.Entry entry = ( Map.Entry ) ti.next();
-            code2Type.put( entry.getValue(), entry.getKey() );
-        }
-        code2Type.put( new Integer( TOKEN_SIMPLE_STRING ), String.class );
-
-        NAME_CHARS = new BitSet();
-        for ( int i = '0'; i <= '9'; i++ )
-            NAME_CHARS.set( i );
-        for ( int i = 'a'; i <= 'z'; i++ )
-            NAME_CHARS.set( i );
-        for ( int i = 'A'; i <= 'Z'; i++ )
-            NAME_CHARS.set( i );
-        NAME_CHARS.set( '_' );
-        NAME_CHARS.set( '-' );
-        NAME_CHARS.set( '.' );
-        NAME_CHARS.set( '\\' );
-
-        TOKEN_CHARS = new BitSet();
-        TOKEN_CHARS.set( TOKEN_EQ );
-        TOKEN_CHARS.set( TOKEN_ARR_OPEN );
-        TOKEN_CHARS.set( TOKEN_ARR_CLOS );
-        TOKEN_CHARS.set( TOKEN_VEC_OPEN );
-        TOKEN_CHARS.set( TOKEN_VEC_CLOS );
-        TOKEN_CHARS.set( TOKEN_COMMA );
-        TOKEN_CHARS.set( TOKEN_VAL_OPEN );
-        TOKEN_CHARS.set( TOKEN_VAL_CLOS );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_STRING );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_INTEGER );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_LONG );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_FLOAT );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_DOUBLE );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_BYTE );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_SHORT );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_CHARACTER );
-        TOKEN_CHARS.set( TOKEN_SIMPLE_BOOLEAN );
-
-        // primitives
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_INT );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_LONG );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_FLOAT );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_DOUBLE );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_BYTE );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_SHORT );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_CHAR );
-        TOKEN_CHARS.set( TOKEN_PRIMITIVE_BOOLEAN );
-    }
-
-
-    /**
-     * Writes the configuration data from the <code>Dictionary</code> to the
-     * given <code>OutputStream</code>.
-     * <p>
-     * This method writes at the current location in the stream and does not
-     * close the outputstream.
-     *
-     * @param out
-     *            The <code>OutputStream</code> to write the configurtion data
-     *            to.
-     * @param properties
-     *            The <code>Dictionary</code> to write.
-     * @throws IOException
-     *             If an error occurrs writing to the output stream.
-     */
-    public static void write( OutputStream out, Dictionary properties ) throws IOException
-    {
-        BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( out, ENCODING ) );
-
-        for ( Enumeration ce = orderedKeys(properties); ce.hasMoreElements(); )
-        {
-            String key = ( String ) ce.nextElement();
-
-            // cfg = prop "=" value "." .
-            writeQuoted( bw, key );
-            bw.write( TOKEN_EQ );
-            writeValue( bw, properties.get( key ) );
-            bw.write( CRLF );
-        }
-
-        bw.flush();
-    }
-
-    public static String write( Object value ) throws IOException
-    {
-        StringWriter sw = new StringWriter();
-        writeValue(sw, value);
-        return sw.toString();
-    }
-
-    /**
-     * Generates an <code>Enumeration</code> for the given
-     * <code>Dictionary</code> where the keys of the <code>Dictionary</code>
-     * are provided in sorted order.
-     *
-     * @param properties
-     *                   The <code>Dictionary</code> that keys are sorted.
-     * @return An <code>Enumeration</code> that provides the keys of
-     *         properties in an ordered manner.
-     */
-    private static Enumeration orderedKeys(Dictionary properties) {
-        String[] keyArray = new String[properties.size()];
-        int i = 0;
-        for ( Enumeration ce = properties.keys(); ce.hasMoreElements(); )
-        {
-            keyArray[i] = ( String ) ce.nextElement();
-            i++;
-        }
-        Arrays.sort(keyArray);
-        return Collections.enumeration( Arrays.asList( keyArray ) );
-    }
-
-
-    /**
-     * Reads configuration data from the given <code>InputStream</code> and
-     * returns a new <code>Dictionary</code> object containing the data.
-     * <p>
-     * This method reads from the current location in the stream upto the end of
-     * the stream but does not close the stream at the end.
-     *
-     * @param ins
-     *            The <code>InputStream</code> from which to read the
-     *            configuration data.
-     * @return A <code>Dictionary</code> object containing the configuration
-     *         data. This object may be empty if the stream contains no
-     *         configuration data.
-     * @throws IOException
-     *             If an error occurrs reading from the stream. This exception
-     *             is also thrown if a syntax error is encountered.
-     */
-    public static Dictionary read( InputStream ins ) throws IOException
-    {
-        return new ConfigurationHandler().readInternal( ins );
-    }
-
-    public static Object read( String value ) throws IOException
-    {
-        PushbackReader pr = new PushbackReader( new StringReader( value ), 1 );
-        ConfigurationHandler ch = new ConfigurationHandler();
-        return ch.readValue(pr);
-    }
-
-    // private constructor, this class is not to be instantiated from the
-    // outside
-    private ConfigurationHandler()
-    {
-    }
-
-    // ---------- Configuration Input Implementation ---------------------------
-
-    private int token;
-    private String tokenValue;
-    private int line;
-    private int pos;
-
-
-    private Dictionary readInternal( InputStream ins ) throws IOException
-    {
-        BufferedReader br = new BufferedReader( new InputStreamReader( ins, ENCODING ) );
-        PushbackReader pr = new PushbackReader( br, 1 );
-
-        token = 0;
-        tokenValue = null;
-        line = 0;
-        pos = 0;
-
-        Hashtable configuration = new Hashtable();
-        token = 0;
-        while ( nextToken( pr, true ) == TOKEN_NAME )
-        {
-            String key = tokenValue;
-
-            // expect equal sign
-            if ( nextToken( pr, false ) != TOKEN_EQ )
-            {
-                throw readFailure( token, TOKEN_EQ );
-            }
-
-            // expect the token value
-            Object value = readValue( pr );
-            if ( value != null )
-            {
-                configuration.put( key, value );
-            }
-        }
-
-        return configuration;
-    }
-
-
-    /**
-     * value = type ( "[" values "]" | "(" values ")" | simple ) .
-     * values = value { "," value } .
-     * simple = "{" stringsimple "}" .
-     * type = // 1-char type code .
-     * stringsimple = // quoted string representation of the value .
-     *
-     * @param pr
-     * @return
-     * @throws IOException
-     */
-    private Object readValue( PushbackReader pr ) throws IOException
-    {
-        // read past any whitespace and (optional) type code
-        int type = ignorableWhiteSpace( pr );
-
-        // read value kind code if type code is not a value kinde code
-        int code;
-        if ( code2Type.containsKey( new Integer( type ) ) )
-        {
-            code = read( pr );
-        }
-        else
-        {
-            code = type;
-            type = TOKEN_SIMPLE_STRING;
-        }
-
-        switch ( code )
-        {
-            case TOKEN_ARR_OPEN:
-                return readArray( type, pr );
-
-            case TOKEN_VEC_OPEN:
-                return readCollection( type, pr );
-
-            case TOKEN_VAL_OPEN:
-                Object value = readSimple( type, pr );
-                ensureNext( pr, TOKEN_VAL_CLOS );
-                return value;
-
-            default:
-                return null;
-        }
-    }
-
-
-    private Object readArray( int typeCode, PushbackReader pr ) throws IOException
-    {
-        List list = new ArrayList();
-        for ( ;; )
-        {
-            int c = ignorablePageBreakAndWhiteSpace( pr );
-            if ( c == TOKEN_VAL_OPEN )
-            {
-                Object value = readSimple( typeCode, pr );
-                if ( value == null )
-                {
-                    // abort due to error
-                    return null;
-                }
-
-                ensureNext( pr, TOKEN_VAL_CLOS );
-
-                list.add( value );
-
-                c = ignorablePageBreakAndWhiteSpace( pr );
-            }
-
-            if ( c == TOKEN_ARR_CLOS )
-            {
-                Class type = ( Class ) code2Type.get( new Integer( typeCode ) );
-                Object array = Array.newInstance( type, list.size() );
-                for ( int i = 0; i < list.size(); i++ )
-                {
-                    Array.set( array, i, list.get( i ) );
-                }
-                return array;
-            }
-            else if ( c < 0 )
-            {
-                return null;
-            }
-            else if ( c != TOKEN_COMMA )
-            {
-                return null;
-            }
-        }
-    }
-
-
-    private Collection readCollection( int typeCode, PushbackReader pr ) throws IOException
-    {
-        Collection collection = new ArrayList();
-        for ( ;; )
-        {
-            int c = ignorablePageBreakAndWhiteSpace( pr );
-            if ( c == TOKEN_VAL_OPEN )
-            {
-                Object value = readSimple( typeCode, pr );
-                if ( value == null )
-                {
-                    // abort due to error
-                    return null;
-                }
-
-                ensureNext( pr, TOKEN_VAL_CLOS );
-
-                collection.add( value );
-
-                c = ignorablePageBreakAndWhiteSpace( pr );
-            }
-
-            if ( c == TOKEN_VEC_CLOS )
-            {
-                return collection;
-            }
-            else if ( c < 0 )
-            {
-                return null;
-            }
-            else if ( c != TOKEN_COMMA )
-            {
-                return null;
-            }
-        }
-    }
-
-
-    private Object readSimple( int code, PushbackReader pr ) throws IOException
-    {
-        switch ( code )
-        {
-            case -1:
-                return null;
-
-            case TOKEN_SIMPLE_STRING:
-                return readQuoted( pr );
-
-                // Simple/Primitive, only use wrapper classes
-            case TOKEN_SIMPLE_INTEGER:
-            case TOKEN_PRIMITIVE_INT:
-                return Integer.valueOf( readQuoted( pr ) );
-
-            case TOKEN_SIMPLE_LONG:
-            case TOKEN_PRIMITIVE_LONG:
-                return Long.valueOf( readQuoted( pr ) );
-
-            case TOKEN_SIMPLE_FLOAT:
-            case TOKEN_PRIMITIVE_FLOAT:
-                String fString = readQuoted( pr );
-                if ( fString.indexOf('.') >= 0 )
-                    return Float.valueOf( fString );
-                else
-                    return Float.intBitsToFloat( Integer.parseInt( fString ) );
-
-            case TOKEN_SIMPLE_DOUBLE:
-            case TOKEN_PRIMITIVE_DOUBLE:
-                String dString = readQuoted( pr );
-                if (dString.indexOf('.') >= 0 )
-                    return Double.valueOf( dString );
-                else
-                    return Double.longBitsToDouble( Long.parseLong( dString ) );
-
-            case TOKEN_SIMPLE_BYTE:
-            case TOKEN_PRIMITIVE_BYTE:
-                return Byte.valueOf( readQuoted( pr ) );
-
-            case TOKEN_SIMPLE_SHORT:
-            case TOKEN_PRIMITIVE_SHORT:
-                return Short.valueOf( readQuoted( pr ) );
-
-            case TOKEN_SIMPLE_CHARACTER:
-            case TOKEN_PRIMITIVE_CHAR:
-                String cString = readQuoted( pr );
-                if ( cString != null && cString.length() > 0 )
-                {
-                    return new Character( cString.charAt( 0 ) );
-                }
-                return null;
-
-            case TOKEN_SIMPLE_BOOLEAN:
-            case TOKEN_PRIMITIVE_BOOLEAN:
-                return Boolean.valueOf( readQuoted( pr ) );
-
-                // unknown type code
-            default:
-                return null;
-        }
-    }
-
-
-    private void ensureNext( PushbackReader pr, int expected ) throws IOException
-    {
-        int next = read( pr );
-        if ( next != expected )
-        {
-            readFailure( next, expected );
-        }
-    }
-
-
-    private String readQuoted( PushbackReader pr ) throws IOException
-    {
-        StringBuffer buf = new StringBuffer();
-        for ( ;; )
-        {
-            int c = read( pr );
-            switch ( c )
-            {
-                // escaped character
-                case '\\':
-                    c = read( pr );
-                    switch ( c )
-                    {
-                        // well known escapes
-                        case 'b':
-                            buf.append( '\b' );
-                            break;
-                        case 't':
-                            buf.append( '\t' );
-                            break;
-                        case 'n':
-                            buf.append( '\n' );
-                            break;
-                        case 'f':
-                            buf.append( '\f' );
-                            break;
-                        case 'r':
-                            buf.append( '\r' );
-                            break;
-                        case 'u':// need 4 characters !
-                            char[] cbuf = new char[4];
-                            if ( read( pr, cbuf ) == 4 )
-                            {
-                                c = Integer.parseInt( new String( cbuf ), 16 );
-                                buf.append( ( char ) c );
-                            }
-                            break;
-
-                        // just an escaped character, unescape
-                        default:
-                            buf.append( ( char ) c );
-                    }
-                    break;
-
-                // eof
-                case -1: // fall through
-
-                // separator token
-                case TOKEN_VAL_CLOS:
-                    pr.unread( c );
-                    return buf.toString();
-
-                // no escaping
-                default:
-                    buf.append( ( char ) c );
-            }
-        }
-    }
-
-    private String readUnquoted( PushbackReader pr ) throws IOException
-    {
-        StringBuffer buf = new StringBuffer();
-        for ( ;; )
-        {
-            int c = read( pr );
-            switch ( c )
-            {
-                // escaped character
-                case '\\':
-                    c = read( pr );
-                    switch ( c )
-                    {
-                        // well known escapes
-                        case 'b':
-                            buf.append( '\b' );
-                            break;
-                        case 't':
-                            buf.append( '\t' );
-                            break;
-                        case 'n':
-                            buf.append( '\n' );
-                            break;
-                        case 'f':
-                            buf.append( '\f' );
-                            break;
-                        case 'r':
-                            buf.append( '\r' );
-                            break;
-                        case 'u':// need 4 characters !
-                            char[] cbuf = new char[4];
-                            if ( read( pr, cbuf ) == 4 )
-                            {
-                                c = Integer.parseInt( new String( cbuf ), 16 );
-                                buf.append( ( char ) c );
-                            }
-                            break;
-
-                        // just an escaped character, unescape
-                        default:
-                            buf.append( ( char ) c );
-                    }
-                    break;
-
-                // eof
-                case -1: // fall through
-
-                // separator token
-                case TOKEN_SPACE:
-                case TOKEN_EQ:
-                case TOKEN_VAL_CLOS:
-                    pr.unread( c );
-                    return buf.toString();
-
-                // no escaping
-                default:
-                    buf.append( ( char ) c );
-            }
-        }
-    }
-
-    private int nextToken( PushbackReader pr, final boolean newLine ) throws IOException
-    {
-        int c = ignorableWhiteSpace( pr );
-
-        // immediately return EOF
-        if ( c < 0 )
-        {
-            return ( token = c );
-        }
-
-        // check for comment
-        if ( newLine && c == TOKEN_COMMENT )
-        {
-            // skip everything until end of line
-            do
-            {
-                c = read( pr );
-            } while ( c != -1 && c != '\n' );
-            if ( c == -1 )
-            {
-                return ( token = c);
-            }
-            // and start over
-            return nextToken( pr, true );
-        }
-
-        // check whether there is a name
-        if ( NAME_CHARS.get( c ) || !TOKEN_CHARS.get( c ) )
-        {
-            // read the property name
-            pr.unread( c );
-            tokenValue = readUnquoted( pr );
-            return ( token = TOKEN_NAME );
-        }
-
-        // check another token
-        if ( TOKEN_CHARS.get( c ) )
-        {
-            return ( token = c );
-        }
-
-        // unexpected character -> so what ??
-        return ( token = -1 );
-    }
-
-
-    private int ignorableWhiteSpace( PushbackReader pr ) throws IOException
-    {
-        int c = read( pr );
-        while ( c >= 0 && Character.isWhitespace( ( char ) c ) )
-        {
-            c = read( pr );
-        }
-        return c;
-    }
-
-
-    private int ignorablePageBreakAndWhiteSpace( PushbackReader pr ) throws IOException
-    {
-        int c = ignorableWhiteSpace( pr );
-        for ( ;; )
-        {
-            if ( c != '\\' )
-            {
-                break;
-            }
-            int c1 = pr.read();
-            if ( c1 == '\r' || c1 == '\n' )
-            {
-                c = ignorableWhiteSpace( pr );
-            } else {
-                pr.unread(c1);
-                break;
-            }
-        }
-        return c;
-    }
-
-
-    private int read( PushbackReader pr ) throws IOException
-    {
-        int c = pr.read();
-        if ( c == '\r' )
-        {
-            int c1 = pr.read();
-            if ( c1 != '\n' )
-            {
-                pr.unread( c1 );
-            }
-            c = '\n';
-        }
-
-        if ( c == '\n' )
-        {
-            line++;
-            pos = 0;
-        }
-        else
-        {
-            pos++;
-        }
-
-        return c;
-    }
-
-
-    private int read( PushbackReader pr, char[] buf ) throws IOException
-    {
-        for ( int i = 0; i < buf.length; i++ )
-        {
-            int c = read( pr );
-            if ( c >= 0 )
-            {
-                buf[i] = ( char ) c;
-            }
-            else
-            {
-                return i;
-            }
-        }
-
-        return buf.length;
-    }
-
-
-    private IOException readFailure( int current, int expected )
-    {
-        return new IOException( "Unexpected token " + current + "; expected: " + expected + " (line=" + line + ", pos="
-            + pos + ")" );
-    }
-
-
-    // ---------- Configuration Output Implementation --------------------------
-
-    private static void writeValue( Writer out, Object value ) throws IOException
-    {
-        Class clazz = value.getClass();
-        if ( clazz.isArray() )
-        {
-            writeArray( out, value );
-        }
-        else if ( value instanceof Collection )
-        {
-            writeCollection( out, ( Collection ) value );
-        }
-        else
-        {
-            writeType( out, clazz );
-            writeSimple( out, value );
-        }
-    }
-
-
-    private static void writeArray( Writer out, Object arrayValue ) throws IOException
-    {
-        int size = Array.getLength( arrayValue );
-        writeType( out, arrayValue.getClass().getComponentType() );
-        out.write( TOKEN_ARR_OPEN );
-        out.write( COLLECTION_LINE_BREAK );
-        for ( int i = 0; i < size; i++ )
-        {
-            writeCollectionElement(out, Array.get( arrayValue, i ));
-        }
-        out.write( INDENT );
-        out.write( TOKEN_ARR_CLOS );
-    }
-
-
-    private static void writeCollection( Writer out, Collection collection ) throws IOException
-    {
-        if ( collection.isEmpty() )
-        {
-            out.write( TOKEN_VEC_OPEN );
-            out.write( COLLECTION_LINE_BREAK );
-            out.write( TOKEN_VEC_CLOS );
-        }
-        else
-        {
-            Iterator ci = collection.iterator();
-            Object firstElement = ci.next();
-
-            writeType( out, firstElement.getClass() );
-            out.write( TOKEN_VEC_OPEN );
-            out.write( COLLECTION_LINE_BREAK );
-
-            writeCollectionElement( out, firstElement );
-
-            while ( ci.hasNext() )
-            {
-                writeCollectionElement( out, ci.next() );
-            }
-            out.write( TOKEN_VEC_CLOS );
-        }
-    }
-
-
-    private static void writeCollectionElement(Writer out, Object element) throws IOException {
-        out.write( INDENT );
-        writeSimple( out, element );
-        out.write( TOKEN_COMMA );
-        out.write(COLLECTION_LINE_BREAK);
-    }
-
-
-    private static void writeType( Writer out, Class valueType ) throws IOException
-    {
-        Integer code = ( Integer ) type2Code.get( valueType );
-        if ( code != null )
-        {
-            out.write( ( char ) code.intValue() );
-        }
-    }
-
-
-    private static void writeSimple( Writer out, Object value ) throws IOException
-    {
-        out.write( TOKEN_VAL_OPEN );
-        writeQuoted( out, String.valueOf( value ) );
-        out.write( TOKEN_VAL_CLOS );
-    }
-
-
-    private static void writeQuoted( Writer out, String simple ) throws IOException
-    {
-        if ( simple == null || simple.length() == 0 )
-        {
-            return;
-        }
-
-        char c = 0;
-        int len = simple.length();
-        for ( int i = 0; i < len; i++ )
-        {
-            c = simple.charAt( i );
-            switch ( c )
-            {
-                case '\\':
-                case TOKEN_VAL_CLOS:
-                    out.write( '\\' );
-                    out.write( c );
-                    break;
-
-                // well known escapes
-                case '\b':
-                    out.write( "\\b" );
-                    break;
-                case '\t':
-                    out.write( "\\t" );
-                    break;
-                case '\n':
-                    out.write( "\\n" );
-                    break;
-                case '\f':
-                    out.write( "\\f" );
-                    break;
-                case '\r':
-                    out.write( "\\r" );
-                    break;
-
-                // other escaping
-                default:
-                    if ( c < ' ' )
-                    {
-                        String t = "000" + Integer.toHexString( c );
-                        out.write( "\\u" + t.substring( t.length() - 4 ) );
-                    }
-                    else
-                    {
-                        out.write( c );
-                    }
-            }
-        }
-    }
+public class ConfigurationHandler {
+
+	/**
+	 * Reads configuration data from the given <code>InputStream</code> and
+	 * returns a new <code>Dictionary</code> object containing the data.
+	 * <p>
+	 * This method reads from the current location in the stream upto the end of
+	 * the stream but does not close the stream at the end.
+	 *
+	 * @param inputStream
+	 *			The <code>InputStream</code> from which to read the
+	 *			configuration data.
+	 * @return A <code>Dictionary</code> object containing the configuration
+	 *		 data. This object may be empty if the stream contains no
+	 *		 configuration data.
+	 * @throws IOException
+	 *			 If an error occurrs reading from the stream. This exception
+	 *			 is also thrown if a syntax error is encountered.
+	 */
+	public static Dictionary read(InputStream inputStream) throws IOException {
+		return new ConfigurationHandler()._readInternal(inputStream);
+	}
+
+	public static Object read(String value) throws IOException {
+		try (StringReader stringReader = new StringReader(value);
+			PushbackReader pushbackReader = new PushbackReader(
+				stringReader, 1)) {
+
+			ConfigurationHandler configurationHandler =
+				new ConfigurationHandler();
+
+			return configurationHandler._readValue(pushbackReader);
+		}
+	}
+
+	public static String write(Object value) throws IOException {
+		StringWriter stringWriter = new StringWriter();
+
+		_writeValue(stringWriter, value);
+
+		return stringWriter.toString();
+	}
+
+	/**
+	 * Writes the configuration data from the <code>Dictionary</code> to the
+	 * given <code>OutputStream</code>.
+	 * <p>
+	 * This method writes at the current location in the stream and does not
+	 * close the outputstream.
+	 *
+	 * @param outputStream
+	 *			The <code>OutputStream</code> to write the configurtion data
+	 *			to.
+	 * @param properties
+	 *			The <code>Dictionary</code> to write.
+	 * @throws IOException
+	 *			 If an error occurrs writing to the output stream.
+	 */
+	public static void write(OutputStream outputStream, Dictionary properties)
+		throws IOException {
+
+		try (OutputStreamWriter outputStreamWriter = new OutputStreamWriter(
+				outputStream, _ENCODING);
+			BufferedWriter bufferedWriter = new BufferedWriter(
+				outputStreamWriter)) {
+
+			Enumeration<String> enumeration = _orderedKeys(properties);
+
+			while (enumeration.hasMoreElements()) {
+				String key = enumeration.nextElement();
+
+				// cfg = prop "=" value "." .
+
+				_writeQuoted(bufferedWriter, key);
+
+				bufferedWriter.write(_TOKEN_EQ);
+
+				_writeValue(bufferedWriter, properties.get(key));
+
+				bufferedWriter.write(_CRLF);
+			}
+
+			bufferedWriter.flush();
+		}
+	}
+
+	/**
+	 * Generates an <code>Enumeration</code> for the given
+	 * <code>Dictionary</code> where the keys of the <code>Dictionary</code>
+	 * are provided in sorted order.
+	 *
+	 * @param properties
+	 *				   The <code>Dictionary</code> that keys are sorted.
+	 * @return An <code>Enumeration</code> that provides the keys of
+	 *		 properties in an ordered manner.
+	 */
+	private static Enumeration<String> _orderedKeys(Dictionary properties) {
+		String[] keyArray = new String[properties.size()];
+		int i = 0;
+
+		for (Enumeration ce = properties.keys(); ce.hasMoreElements();) {
+			keyArray[i] = (String)ce.nextElement();
+			i++;
+		}
+
+		Arrays.sort(keyArray);
+
+		return Collections.enumeration(Arrays.asList(keyArray));
+	}
+
+	private static void _writeArray(Writer writer, Object arrayValue)
+		throws IOException {
+
+		int size = Array.getLength(arrayValue);
+
+		Class<?> clazz = arrayValue.getClass();
+
+		_writeType(writer, clazz.getComponentType());
+
+		writer.write(_TOKEN_ARR_OPEN);
+
+		writer.write(_COLLECTION_LINE_BREAK);
+
+		for (int i = 0; i < size; i++) {
+			_writeCollectionElement(writer, Array.get(arrayValue, i));
+		}
+
+		writer.write(_INDENT);
+		writer.write(_TOKEN_ARR_CLOS);
+	}
+
+	private static void _writeCollection(Writer writer, Collection collection)
+		throws IOException {
+
+		if (collection.isEmpty()) {
+			writer.write(_TOKEN_VEC_OPEN);
+			writer.write(_COLLECTION_LINE_BREAK);
+			writer.write(_TOKEN_VEC_CLOS);
+		}
+		else {
+			Iterator iterator = collection.iterator();
+
+			Object firstElement = iterator.next();
+
+			_writeType(writer, firstElement.getClass());
+
+			writer.write(_TOKEN_VEC_OPEN);
+			writer.write(_COLLECTION_LINE_BREAK);
+
+			_writeCollectionElement(writer, firstElement);
+
+			while (iterator.hasNext()) {
+				_writeCollectionElement(writer, iterator.next());
+			}
+
+			writer.write(_TOKEN_VEC_CLOS);
+		}
+	}
+
+	private static void _writeCollectionElement(Writer writer, Object element)
+		throws IOException {
+
+		writer.write(_INDENT);
+
+		_writeSimple(writer, element);
+
+		writer.write(_TOKEN_COMMA);
+		writer.write(_COLLECTION_LINE_BREAK);
+	}
+
+	private static void _writeQuoted(Writer writer, String simple)
+		throws IOException {
+
+		if ((simple == null) || (simple.length() == 0)) {
+			return;
+		}
+
+		char c = 0;
+
+		int length = simple.length();
+
+		for (int i = 0; i < length; i++) {
+			c = simple.charAt(i);
+
+			if ((c == '\\') || (c == _TOKEN_VAL_CLOS)) {
+				writer.write('\\');
+				writer.write(c);
+			}
+			else if (c == '\b') {
+				writer.write("\\b");
+			}
+			else if (c == '\t') {
+				writer.write("\\t");
+			}
+			else if (c == '\n') {
+				writer.write("\\n");
+			}
+			else if (c == '\f') {
+				writer.write("\\f");
+			}
+			else if (c == '\r') {
+				writer.write("\\r");
+			}
+			else if (c < ' ') {
+				String hexString = "000" + Integer.toHexString(c);
+
+				writer.write(
+					"\\u" + hexString.substring(hexString.length() - 4));
+			}
+			else {
+				writer.write(c);
+			}
+		}
+	}
+
+	private static void _writeSimple(Writer writer, Object value)
+		throws IOException {
+
+		writer.write(_TOKEN_VAL_OPEN);
+
+		_writeQuoted(writer, String.valueOf(value));
+
+		writer.write(_TOKEN_VAL_CLOS);
+	}
+
+	private static void _writeType(Writer writer, Class valueType)
+		throws IOException {
+
+		Integer code = (Integer)_typeToCode.get(valueType);
+
+		if (code != null) {
+			writer.write((char)code.intValue());
+		}
+	}
+
+	private static void _writeValue(Writer writer, Object value)
+		throws IOException {
+
+		Class<?> clazz = value.getClass();
+
+		if (clazz.isArray()) {
+			_writeArray(writer, value);
+		}
+		else if (value instanceof Collection) {
+			_writeCollection(writer, (Collection)value);
+		}
+		else {
+			_writeType(writer, clazz);
+			_writeSimple(writer, value);
+		}
+	}
+
+	// simple types (string & primitive wrappers)
+
+	private ConfigurationHandler() {
+	}
+
+	private void _ensureNext(PushbackReader pushbackReader, int expected)
+		throws IOException {
+
+		int next = _read(pushbackReader);
+
+		if (next != expected) {
+			_readFailure(next, expected);
+		}
+	}
+
+	private int _ignorablePageBreakAndWhiteSpace(PushbackReader pushbackReader)
+		throws IOException {
+
+		int c1 = _ignorableWhiteSpace(pushbackReader);
+
+		while (true) {
+			if (c1 != '\\') {
+				break;
+			}
+
+			int c2 = pushbackReader.read();
+
+			if ((c2 == '\r') || (c2 == '\n')) {
+				c1 = _ignorableWhiteSpace(pushbackReader);
+			}
+			else {
+				pushbackReader.unread(c2);
+
+				break;
+			}
+		}
+
+		return c1;
+	}
+
+	private int _ignorableWhiteSpace(PushbackReader pushbackReader)
+		throws IOException {
+
+		int c = _read(pushbackReader);
+
+		while ((c >= 0) && Character.isWhitespace((char)c)) {
+			c = _read(pushbackReader);
+		}
+
+		return c;
+	}
+
+	private int _nextToken(PushbackReader pushbackReader, boolean newLine)
+		throws IOException {
+
+		int c = _ignorableWhiteSpace(pushbackReader);
+
+		// immediately return EOF
+
+		if (c < 0) {
+			return _token = c;
+		}
+
+		// check for comment
+
+		if (newLine && (c == _TOKEN_COMMENT)) {
+
+			// skip everything until end of line
+
+			do {
+				c = _read(pushbackReader);
+			}
+			while ((c != -1) && (c != '\n'));
+
+			if (c == -1) {
+				return _token = c;
+			}
+
+			// and start over
+
+			return _nextToken(pushbackReader, true);
+		}
+
+		// check whether there is a name
+
+		if (_NAME_CHARS.get(c) || !_TOKEN_CHARS.get(c)) {
+
+			// read the property name
+
+			pushbackReader.unread(c);
+
+			_tokenValue = _readUnquoted(pushbackReader);
+
+			_token = _TOKEN_NAME;
+
+			return _TOKEN_NAME;
+		}
+
+		// check another token
+
+		if (_TOKEN_CHARS.get(c)) {
+			_token = c;
+
+			return c;
+		}
+
+		// unexpected character -> so what ??
+
+		_token = -1;
+
+		return _token;
+	}
+
+	private int _read(PushbackReader pushbackReader) throws IOException {
+		int c = pushbackReader.read();
+
+		if (c == '\r') {
+			int c1 = pushbackReader.read();
+
+			if (c1 != '\n') {
+				pushbackReader.unread(c1);
+			}
+
+			c = '\n';
+		}
+
+		if (c == '\n') {
+			_line++;
+			_pos = 0;
+		}
+		else {
+			_pos++;
+		}
+
+		return c;
+	}
+
+	private int _read(PushbackReader pushbackReader, char[] buffer)
+		throws IOException {
+
+		for (int i = 0; i < buffer.length; i++) {
+			int c = _read(pushbackReader);
+
+			if (c >= 0) {
+				buffer[i] = (char)c;
+			}
+			else {
+				return i;
+			}
+		}
+
+		return buffer.length;
+	}
+
+	private Object _readArray(int typeCode, PushbackReader pushbackReader)
+		throws IOException {
+
+		List<Object> list = new ArrayList<>();
+
+		while (true) {
+			int spaces = _ignorablePageBreakAndWhiteSpace(pushbackReader);
+
+			if (spaces == _TOKEN_VAL_OPEN) {
+				Object value = _readSimple(typeCode, pushbackReader);
+
+				if (value == null) {
+
+					// abort due to error
+
+					return null;
+				}
+
+				_ensureNext(pushbackReader, _TOKEN_VAL_CLOS);
+
+				list.add(value);
+
+				spaces = _ignorablePageBreakAndWhiteSpace(pushbackReader);
+			}
+
+			if (spaces == _TOKEN_ARR_CLOS) {
+				Class<?> type = (Class)_codeToType.get(typeCode);
+
+				Object array = Array.newInstance(type, list.size());
+
+				for (int i = 0; i < list.size(); i++) {
+					Array.set(array, i, list.get(i));
+				}
+
+				return array;
+			}
+			else if (spaces < 0) {
+				return null;
+			}
+			else if (spaces != _TOKEN_COMMA) {
+				return null;
+			}
+		}
+	}
+
+	private Collection<Object> _readCollection(
+			int typeCode, PushbackReader pushbackReader)
+		throws IOException {
+
+		Collection<Object> collection = new ArrayList<>();
+
+		while (true) {
+			int spaces = _ignorablePageBreakAndWhiteSpace(pushbackReader);
+
+			if (spaces == _TOKEN_VAL_OPEN) {
+				Object value = _readSimple(typeCode, pushbackReader);
+
+				if (value == null) {
+
+					// abort due to error
+
+					return null;
+				}
+
+				_ensureNext(pushbackReader, _TOKEN_VAL_CLOS);
+
+				collection.add(value);
+
+				spaces = _ignorablePageBreakAndWhiteSpace(pushbackReader);
+			}
+
+			if (spaces == _TOKEN_VEC_CLOS) {
+				return collection;
+			}
+			else if (spaces < 0) {
+				return null;
+			}
+			else if (spaces != _TOKEN_COMMA) {
+				return null;
+			}
+		}
+	}
+
+	// primitives
+
+	private IOException _readFailure(int current, int expected) {
+		StringBuilder sb = new StringBuilder();
+
+		sb.append("Unexpected token ");
+		sb.append(current);
+		sb.append("; expected: ");
+		sb.append(expected);
+		sb.append(" (line=");
+		sb.append(_line);
+		sb.append(", pos=");
+		sb.append(_pos);
+		sb.append(")");
+
+		return new IOException(sb.toString());
+	}
+
+	private Dictionary<String, Object> _readInternal(InputStream inputStream)
+		throws IOException {
+
+		try (InputStreamReader inputStreamReader = new InputStreamReader(
+				inputStream, _ENCODING);
+			BufferedReader bufferedReader = new BufferedReader(
+				inputStreamReader);
+			PushbackReader pushbackReader = new PushbackReader(
+				bufferedReader, 1)) {
+
+			_token = 0;
+			_tokenValue = null;
+			_line = 0;
+			_pos = 0;
+
+			Dictionary<String, Object> configuration = new Hashtable<>();
+
+			_token = 0;
+
+			while (_nextToken(pushbackReader, true) == _TOKEN_NAME) {
+				String key = _tokenValue;
+
+				// expect equal sign
+
+				if (_nextToken(pushbackReader, false) != _TOKEN_EQ) {
+					throw _readFailure(_token, _TOKEN_EQ);
+				}
+
+				// expect the token value
+
+				Object value = _readValue(pushbackReader);
+
+				if (value != null) {
+					configuration.put(key, value);
+				}
+			}
+
+			return configuration;
+		}
+	}
+
+	private String _readQuoted(PushbackReader pushbackReader)
+		throws IOException {
+
+		StringBuffer buffer = new StringBuffer();
+
+		while (true) {
+			int c = _read(pushbackReader);
+
+			if (c == '\\') {
+				c = _read(pushbackReader);
+
+				if (c == 'b') {
+					buffer.append('\b');
+				}
+				else if (c == 't') {
+					buffer.append('\t');
+				}
+				else if (c == 'n') {
+					buffer.append('\n');
+				}
+				else if (c == 'f') {
+					buffer.append('\f');
+				}
+				else if (c == 'r') {
+					buffer.append('\r');
+				}
+				else if (c == 'u') {
+					char[] charBuffer = new char[4];
+
+					if (_read(pushbackReader, charBuffer) == 4) {
+						c = Integer.parseInt(new String(charBuffer), 16);
+
+						buffer.append((char)c);
+					}
+				}
+				else {
+					buffer.append((char)c);
+				}
+			}
+			else if ((c == -1) || (c == _TOKEN_VAL_CLOS)) {
+				pushbackReader.unread(c);
+
+				return buffer.toString();
+			}
+			else {
+				buffer.append((char)c);
+			}
+		}
+	}
+
+	private Object _readSimple(int code, PushbackReader pushbackReader)
+		throws IOException {
+
+		if (code == -1) {
+			return null;
+		}
+		else if (code == _TOKEN_SIMPLE_STRING) {
+			return _readQuoted(pushbackReader);
+		}
+		else if ((code == _TOKEN_SIMPLE_INTEGER) ||
+				 (code == _TOKEN_PRIMITIVE_INT)) {
+
+			return Integer.valueOf(_readQuoted(pushbackReader));
+		}
+		else if ((code == _TOKEN_SIMPLE_LONG) ||
+				 (code == _TOKEN_PRIMITIVE_LONG)) {
+
+			return Long.valueOf(_readQuoted(pushbackReader));
+		}
+		else if ((code == _TOKEN_SIMPLE_FLOAT) ||
+				 (code == _TOKEN_PRIMITIVE_FLOAT)) {
+
+			String floatString = _readQuoted(pushbackReader);
+
+			if (floatString.indexOf('.') >= 0) {
+				return Float.valueOf(floatString);
+			}
+
+			return Float.intBitsToFloat(Integer.parseInt(floatString));
+		}
+		else if ((code == _TOKEN_SIMPLE_DOUBLE) ||
+				 (code == _TOKEN_PRIMITIVE_DOUBLE)) {
+
+			String doubleString = _readQuoted(pushbackReader);
+
+			if (doubleString.indexOf('.') >= 0) {
+				return Double.valueOf(doubleString);
+			}
+
+			return Double.longBitsToDouble(Long.parseLong(doubleString));
+		}
+		else if ((code == _TOKEN_SIMPLE_BYTE) ||
+				 (code == _TOKEN_PRIMITIVE_BYTE)) {
+
+			return Byte.valueOf(_readQuoted(pushbackReader));
+		}
+		else if ((code == _TOKEN_SIMPLE_SHORT) ||
+				 (code == _TOKEN_PRIMITIVE_SHORT)) {
+
+			return Short.valueOf(_readQuoted(pushbackReader));
+		}
+		else if ((code == _TOKEN_SIMPLE_CHARACTER) ||
+				 (code == _TOKEN_PRIMITIVE_CHAR)) {
+
+			String charString = _readQuoted(pushbackReader);
+
+			if ((charString != null) && (charString.length() > 0)) {
+				return Character.valueOf(charString.charAt(0));
+			}
+
+			return null;
+		}
+		else if ((code == _TOKEN_SIMPLE_BOOLEAN) ||
+				 (code == _TOKEN_PRIMITIVE_BOOLEAN)) {
+
+			return Boolean.valueOf(_readQuoted(pushbackReader));
+		}
+		else {
+			return null;
+		}
+	}
+
+	private String _readUnquoted(PushbackReader pushbackReader)
+		throws IOException {
+
+		StringBuffer buffer = new StringBuffer();
+
+		while (true) {
+			int c = _read(pushbackReader);
+
+			if (c == '\\') {
+				c = _read(pushbackReader);
+
+				if (c == 'b') {
+					buffer.append('\b');
+				}
+				else if (c == 't') {
+					buffer.append('\t');
+				}
+				else if (c == 'n') {
+					buffer.append('\n');
+				}
+				else if (c == 'f') {
+					buffer.append('\f');
+				}
+				else if (c == 'r') {
+					buffer.append('\r');
+				}
+				else if (c == 'u') {
+					char[] charBuffer = new char[4];
+
+					if (_read(pushbackReader, charBuffer) == 4) {
+						c = Integer.parseInt(new String(charBuffer), 16);
+
+						buffer.append((char)c);
+					}
+				}
+				else {
+					buffer.append((char)c);
+				}
+			}
+			else if ((c == -1) || (c == _TOKEN_VAL_CLOS) ||
+					 (c == _TOKEN_SPACE) || (c == _TOKEN_EQ)) {
+
+				pushbackReader.unread(c);
+
+				return buffer.toString();
+			}
+			else {
+				buffer.append((char)c);
+			}
+		}
+	}
+
+	/**
+	 * value = type ("[" values "]" | "(" values ")" | simple) .
+	 * values = value { "," value } .
+	 * simple = "{" stringsimple "}" .
+	 * type = // 1-char type code .
+	 * stringsimple = // quoted string representation of the value .
+	 *
+	 * @param pushbackReader
+	 * @return
+	 * @throws IOException
+	 */
+	private Object _readValue(PushbackReader pushbackReader)
+		throws IOException {
+
+		// read past any whitespace and (optional) type code
+
+		int type = _ignorableWhiteSpace(pushbackReader);
+
+		// read value kind code if type code is not a value kinde code
+
+		int code = type;
+
+		if (_codeToType.containsKey(type)) {
+			code = _read(pushbackReader);
+		}
+		else {
+			type = _TOKEN_SIMPLE_STRING;
+		}
+
+		if (code == _TOKEN_ARR_OPEN) {
+			return _readArray(type, pushbackReader);
+		}
+		else if (code == _TOKEN_VEC_OPEN) {
+			return _readCollection(type, pushbackReader);
+		}
+		else if (code == _TOKEN_VAL_OPEN) {
+			Object value = _readSimple(type, pushbackReader);
+
+			_ensureNext(pushbackReader, _TOKEN_VAL_CLOS);
+
+			return value;
+		}
+		else {
+			return null;
+		}
+	}
+
+	private static final String _COLLECTION_LINE_BREAK = " \\\r\n";
+
+	private static final String _CRLF = "\r\n";
+
+	private static final String _ENCODING = "UTF-8";
+
+	private static final String _INDENT = "  ";
+
+	private static final BitSet _NAME_CHARS = new BitSet() {
+		{
+			for (int i = '0'; i <= '9'; i++) {
+				set(i);
+			}
+
+			for (int i = 'a'; i <= 'z'; i++) {
+				set(i);
+			}
+
+			for (int i = 'A'; i <= 'Z'; i++) {
+				set(i);
+			}
+
+			set('_');
+			set('-');
+			set('.');
+			set('\\');
+		}
+	};
+
+	private static final int _TOKEN_ARR_CLOS = ']';
+
+	private static final int _TOKEN_ARR_OPEN = '[';
+
+	// set of valid characters for "symblic-name"
+
+	private static final BitSet _TOKEN_CHARS = new BitSet() {
+		{
+			set(_TOKEN_EQ);
+			set(_TOKEN_ARR_OPEN);
+			set(_TOKEN_ARR_CLOS);
+			set(_TOKEN_VEC_OPEN);
+			set(_TOKEN_VEC_CLOS);
+			set(_TOKEN_COMMA);
+			set(_TOKEN_VAL_OPEN);
+			set(_TOKEN_VAL_CLOS);
+			set(_TOKEN_SIMPLE_STRING);
+			set(_TOKEN_SIMPLE_INTEGER);
+			set(_TOKEN_SIMPLE_LONG);
+			set(_TOKEN_SIMPLE_FLOAT);
+			set(_TOKEN_SIMPLE_DOUBLE);
+			set(_TOKEN_SIMPLE_BYTE);
+			set(_TOKEN_SIMPLE_SHORT);
+			set(_TOKEN_SIMPLE_CHARACTER);
+			set(_TOKEN_SIMPLE_BOOLEAN);
+
+			// primitives
+
+			set(_TOKEN_PRIMITIVE_INT);
+			set(_TOKEN_PRIMITIVE_LONG);
+			set(_TOKEN_PRIMITIVE_FLOAT);
+			set(_TOKEN_PRIMITIVE_DOUBLE);
+			set(_TOKEN_PRIMITIVE_BYTE);
+			set(_TOKEN_PRIMITIVE_SHORT);
+			set(_TOKEN_PRIMITIVE_CHAR);
+			set(_TOKEN_PRIMITIVE_BOOLEAN);
+		}
+	};
+
+	private static final int _TOKEN_COMMA = ',';
+
+	private static final int _TOKEN_COMMENT = '#';
+
+	private static final int _TOKEN_EQ = '=';
+
+	private static final int _TOKEN_NAME = 'N';
+
+	private static final int _TOKEN_PRIMITIVE_BOOLEAN = 'b';
+
+	private static final int _TOKEN_PRIMITIVE_BYTE = 'x';
+
+	// private constructor, this class is not to be instantiated from the
+	// outside
+
+	private static final int _TOKEN_PRIMITIVE_CHAR = 'c';
+
+	// ---------- Configuration Input Implementation ---------------------------
+
+	private static final int _TOKEN_PRIMITIVE_DOUBLE = 'd';
+
+	private static final int _TOKEN_PRIMITIVE_FLOAT = 'f';
+
+	private static final int _TOKEN_PRIMITIVE_INT = 'i';
+
+	private static final int _TOKEN_PRIMITIVE_LONG = 'l';
+
+	private static final int _TOKEN_PRIMITIVE_SHORT = 's';
+
+	private static final int _TOKEN_SIMPLE_BOOLEAN = 'B';
+
+	private static final int _TOKEN_SIMPLE_BYTE = 'X';
+
+	private static final int _TOKEN_SIMPLE_CHARACTER = 'C';
+
+	private static final int _TOKEN_SIMPLE_DOUBLE = 'D';
+
+	private static final int _TOKEN_SIMPLE_FLOAT = 'F';
+
+	private static final int _TOKEN_SIMPLE_INTEGER = 'I';
+
+	private static final int _TOKEN_SIMPLE_LONG = 'L';
+
+	private static final int _TOKEN_SIMPLE_SHORT = 'S';
+
+	private static final int _TOKEN_SIMPLE_STRING = 'T';
+
+	private static final int _TOKEN_SPACE = ' ';
+
+	private static final int _TOKEN_VAL_CLOS = '"'; // '}';
+
+	private static final int _TOKEN_VAL_OPEN = '"'; // '{';
+
+	private static final int _TOKEN_VEC_CLOS = ')';
+
+	// ---------- Configuration Output Implementation --------------------------
+
+	private static final int _TOKEN_VEC_OPEN = '(';
+
+	private static final Map<Object, Object> _typeToCode =
+		new HashMap<Object, Object>() {
+			{
+				put(Boolean.class, Integer.valueOf(_TOKEN_SIMPLE_BOOLEAN));
+				put(Byte.class, Integer.valueOf(_TOKEN_SIMPLE_BYTE));
+				put(Character.class, Integer.valueOf(_TOKEN_SIMPLE_CHARACTER));
+				put(Double.class, Integer.valueOf(_TOKEN_SIMPLE_DOUBLE));
+				put(Float.class, Integer.valueOf(_TOKEN_SIMPLE_FLOAT));
+				put(Integer.class, Integer.valueOf(_TOKEN_SIMPLE_INTEGER));
+				put(Long.class, Integer.valueOf(_TOKEN_SIMPLE_LONG));
+				put(Short.class, Integer.valueOf(_TOKEN_SIMPLE_SHORT));
+
+				// primitives
+
+				put(Boolean.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_BOOLEAN));
+				put(Byte.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_BYTE));
+				put(Character.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_CHAR));
+				put(Double.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_DOUBLE));
+				put(Float.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_FLOAT));
+				put(Integer.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_INT));
+				put(Long.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_LONG));
+				put(Short.TYPE, Integer.valueOf(_TOKEN_PRIMITIVE_SHORT));
+			}
+		};
+
+	private static final Map<Object, Object> _codeToType =
+		new HashMap<Object, Object>() {
+			{
+
+				// reverse map to map type codes to classes, string class
+				// mapping to be added manually, as the string type code is not
+				// written and hence not included in the type2Code map
+
+				for (Map.Entry<Object, Object> entry : _typeToCode.entrySet()) {
+					put(entry.getValue(), entry.getKey());
+				}
+
+				put(Integer.valueOf(_TOKEN_SIMPLE_STRING), String.class);
+			}
+		};
+
+	private int _line;
+	private int _pos;
+	private int _token;
+	private String _tokenValue;
+
 }
+/* @generated */
\ No newline at end of file
diff --git a/org/apache/felix/utils/properties/InterpolationHelper.java b/org/apache/felix/utils/properties/InterpolationHelper.java
index 2097188..4ee01df 100644
--- a/org/apache/felix/utils/properties/InterpolationHelper.java
+++ b/org/apache/felix/utils/properties/InterpolationHelper.java
@@ -6,7 +6,7 @@
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *	  http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.felix.utils.properties;
 
 import java.util.HashMap;
@@ -21,7 +22,6 @@ import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-
 import org.osgi.framework.BundleContext;
 
 /**
@@ -34,448 +34,509 @@ import org.osgi.framework.BundleContext;
  */
 public class InterpolationHelper {
 
-    private InterpolationHelper() {
-    }
-
-    private static final char   ESCAPE_CHAR = '\\';
-    private static final String DELIM_START = "${";
-    private static final String DELIM_STOP = "}";
-    private static final String MARKER = "$__";
-    private static final String ENV_PREFIX = "env:";
-
-    private static final Pattern ESCAPED_OPENING_CURLY = Pattern.compile("\\\\+\\{");
-    private static final Pattern ESCAPED_CLOSING_CURLY = Pattern.compile("\\\\+\\}");
-    private static final Pattern EXISTING_SUBST_VAR = Pattern.compile(".*\\$\\\\*\\{.*\\}.*");
-
-
-    /**
-     * Callback for substitution
-     */
-    public interface SubstitutionCallback {
-
-        String getValue(String key);
-
-    }
-
-    /**
-     * Perform substitution on a property set
-     *
-     * @param properties the property set to perform substitution on
-     */
-    public static void performSubstitution(Map<String,String> properties)
-    {
-        performSubstitution(properties, (BundleContext) null);
-    }
-
-    /**
-     * Perform substitution on a property set
-     *
-     * @param properties the property set to perform substitution on
-     * @param context The bundle context
-     */
-    public static void performSubstitution(Map<String,String> properties, BundleContext context)
-    {
-        performSubstitution(properties, new BundleContextSubstitutionCallback(context));
-    }
-
-    /**
-     * Perform substitution on a property set
-     *
-     * @param properties the property set to perform substitution on
-     * @param callback Callback for substituion
-     */
-    public static void performSubstitution(Map<String,String> properties, SubstitutionCallback callback)
-    {
-        performSubstitution(properties, callback, true, true, true);
-    }
-
-    /**
-     * Perform substitution on a property set
-     *
-     * @param properties the property set to perform substitution on
-     * @param callback the callback to obtain substitution values
-     * @param substituteFromConfig If substitute from configuration
-     * @param substituteFromSystemProperties If substitute from system properties
-     * @param defaultsToEmptyString sets an empty string if a replacement value is not found, leaves intact otherwise
-     */
-    public static void performSubstitution(Map<String,String> properties,
-                                           SubstitutionCallback callback,
-                                           boolean substituteFromConfig,
-                                           boolean substituteFromSystemProperties,
-                                           boolean defaultsToEmptyString)
-    {
-        Map<String, String> org = new HashMap<String, String>(properties);
-        for (String name : properties.keySet())
-        {
-            String value = properties.get(name);
-            properties.put(name, substVars(value, name, null, org, callback, substituteFromConfig, substituteFromSystemProperties, defaultsToEmptyString));
-        }
-    }
-
-    /**
-     * <p>
-     * This method performs property variable substitution on the
-     * specified value. If the specified value contains the syntax
-     * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
-     * refers to either a configuration property or a system property,
-     * then the corresponding property value is substituted for the variable
-     * placeholder. Multiple variable placeholders may exist in the
-     * specified value as well as nested variable placeholders, which
-     * are substituted from inner most to outer most. Configuration
-     * properties override system properties.
-     * </p>
-     *
-     * @param val The string on which to perform property substitution.
-     * @param currentKey The key of the property being evaluated used to
-     *        detect cycles.
-     * @param cycleMap Map of variable references used to detect nested cycles.
-     * @param configProps Set of configuration properties.
-     * @return The value of the specified string after system property substitution.
-     * @throws IllegalArgumentException If there was a syntax error in the
-     *         property placeholder syntax or a recursive variable reference.
-     **/
-    public static String substVars(String val,
-                                   String currentKey,
-                                   Map<String,String> cycleMap,
-                                   Map<String,String> configProps)
-            throws IllegalArgumentException
-    {
-        return substVars(val, currentKey, cycleMap, configProps, (SubstitutionCallback) null);
-    }
-
-    /**
-     * <p>
-     * This method performs property variable substitution on the
-     * specified value. If the specified value contains the syntax
-     * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
-     * refers to either a configuration property or a system property,
-     * then the corresponding property value is substituted for the variable
-     * placeholder. Multiple variable placeholders may exist in the
-     * specified value as well as nested variable placeholders, which
-     * are substituted from inner most to outer most. Configuration
-     * properties override system properties.
-     * </p>
-     *
-     * @param val The string on which to perform property substitution.
-     * @param currentKey The key of the property being evaluated used to
-     *        detect cycles.
-     * @param cycleMap Map of variable references used to detect nested cycles.
-     * @param configProps Set of configuration properties.
-     * @param context the bundle context to retrieve properties from
-     * @return The value of the specified string after system property substitution.
-     * @throws IllegalArgumentException If there was a syntax error in the
-     *         property placeholder syntax or a recursive variable reference.
-     **/
-    public static String substVars(String val,
-                                   String currentKey,
-                                   Map<String,String> cycleMap,
-                                   Map<String,String> configProps,
-                                   BundleContext context)
-            throws IllegalArgumentException
-    {
-        return substVars(val, currentKey, cycleMap, configProps, new BundleContextSubstitutionCallback(context));
-    }
-
-    /**
-     * <p>
-     * This method performs property variable substitution on the
-     * specified value. If the specified value contains the syntax
-     * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
-     * refers to either a configuration property or a system property,
-     * then the corresponding property value is substituted for the variable
-     * placeholder. Multiple variable placeholders may exist in the
-     * specified value as well as nested variable placeholders, which
-     * are substituted from inner most to outer most. Configuration
-     * properties override system properties.
-     * </p>
-     *
-     * @param val The string on which to perform property substitution.
-     * @param currentKey The key of the property being evaluated used to
-     *        detect cycles.
-     * @param cycleMap Map of variable references used to detect nested cycles.
-     * @param configProps Set of configuration properties.
-     * @param callback the callback to obtain substitution values
-     * @return The value of the specified string after system property substitution.
-     * @throws IllegalArgumentException If there was a syntax error in the
-     *         property placeholder syntax or a recursive variable reference.
-     **/
-    public static String substVars(String val,
-                                   String currentKey,
-                                   Map<String,String> cycleMap,
-                                   Map<String,String> configProps,
-                                   SubstitutionCallback callback)
-            throws IllegalArgumentException
-    {
-        return substVars(val, currentKey, cycleMap, configProps, callback, true, true, true);
-    }
-
-    /**
-     * <p>
-     * This method performs property variable substitution on the
-     * specified value. If the specified value contains the syntax
-     * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
-     * refers to either a configuration property or a system property,
-     * then the corresponding property value is substituted for the variable
-     * placeholder. Multiple variable placeholders may exist in the
-     * specified value as well as nested variable placeholders, which
-     * are substituted from inner most to outer most. Configuration
-     * properties override system properties.
-     * </p>
-     *
-     * @param val The string on which to perform property substitution.
-     * @param currentKey The key of the property being evaluated used to
-     *        detect cycles.
-     * @param cycleMap Map of variable references used to detect nested cycles.
-     * @param configProps Set of configuration properties.
-     * @param callback the callback to obtain substitution values
-     * @param substituteFromConfig If substitute from configuration
-     * @param substituteFromSystemProperties If substitute from system properties
-     * @param defaultsToEmptyString sets an empty string if a replacement value is not found, leaves intact otherwise
-     * @return The value of the specified string after system property substitution.
-     * @throws IllegalArgumentException If there was a syntax error in the
-     *         property placeholder syntax or a recursive variable reference.
-     **/
-    public static String substVars(String val,
-                                   String currentKey,
-                                   Map<String,String> cycleMap,
-                                   Map<String,String> configProps,
-                                   SubstitutionCallback callback,
-                                   boolean substituteFromConfig,
-                                   boolean substituteFromSystemProperties,
-                                   boolean defaultsToEmptyString)
-            throws IllegalArgumentException
-    {
-        return unescape(doSubstVars(val, currentKey, cycleMap, configProps, callback, substituteFromConfig, substituteFromSystemProperties, defaultsToEmptyString));
-    }
-
-    private static String doSubstVars(String val,
-                                      String currentKey,
-                                      Map<String,String> cycleMap,
-                                      Map<String,String> configProps,
-                                      SubstitutionCallback callback,
-                                      boolean substituteFromConfig,
-                                      boolean substituteFromSystemProperties,
-                                      boolean defaultsToEmptyString)
-            throws IllegalArgumentException
-    {
-        if (cycleMap == null)
-        {
-            cycleMap = new HashMap<String,String>();
-        }
-
-        // Put the current key in the cycle map.
-        cycleMap.put(currentKey, currentKey);
-
-        // Assume we have a value that is something like:
-        // "leading ${foo.${bar}} middle ${baz} trailing"
-
-        // Find the first ending '}' variable delimiter, which
-        // will correspond to the first deepest nested variable
-        // placeholder.
-        int startDelim;
-        int stopDelim = -1;
-        do
-        {
-            stopDelim = val.indexOf(DELIM_STOP, stopDelim + 1);
-            while (stopDelim > 0 && val.charAt(stopDelim - 1) == ESCAPE_CHAR)
-            {
-                stopDelim = val.indexOf(DELIM_STOP, stopDelim + 1);
-            }
-
-            // Find the matching starting "${" variable delimiter
-            // by looping until we find a start delimiter that is
-            // greater than the stop delimiter we have found.
-            startDelim = val.indexOf(DELIM_START);
-            while (stopDelim >= 0)
-            {
-                int idx = val.indexOf(DELIM_START, startDelim + DELIM_START.length());
-                if ((idx < 0) || (idx > stopDelim))
-                {
-                    break;
-                }
-                else if (idx < stopDelim)
-                {
-                    startDelim = idx;
-                }
-            }
-        }
-        while (startDelim >= 0 && stopDelim >= 0 && stopDelim < startDelim + DELIM_START.length());
-
-        // If we do not have a start or stop delimiter, then just
-        // return the existing value.
-        if ((startDelim < 0) || (stopDelim < 0))
-        {
-            cycleMap.remove(currentKey);
-            return val;
-        }
-
-        // At this point, we have found a variable placeholder so
-        // we must perform a variable substitution on it.
-        // Using the start and stop delimiter indices, extract
-        // the first, deepest nested variable placeholder.
-        String variable = val.substring(startDelim + DELIM_START.length(), stopDelim);
-        String org = variable;
-
-        // Strip expansion modifiers
-        int idx1 = variable.lastIndexOf(":-");
-        int idx2 = variable.lastIndexOf(":+");
-        int idx = idx1 >= 0 && idx2 >= 0 ? Math.min(idx1, idx2) : idx1 >= 0 ? idx1 : idx2;
-        String op = null;
-        if (idx >= 0 && idx < variable.length())
-        {
-            op = variable.substring(idx);
-            variable = variable.substring(0, idx);
-        }
-
-        // Verify that this is not a recursive variable reference.
-        if (cycleMap.get(variable) != null)
-        {
-            throw new IllegalArgumentException("recursive variable reference: " + variable);
-        }
-
-        String substValue = null;
-        // Get the value of the deepest nested variable placeholder.
-        // Try to configuration properties first.
-        if (substituteFromConfig && configProps != null)
-        {
-            substValue = configProps.get(variable);
-        }
-        if (substValue == null)
-        {
-            if (variable.length() > 0)
-            {
-                if (callback != null)
-                {
-                    substValue = callback.getValue(variable);
-                }
-                if (substValue == null && substituteFromSystemProperties)
-                {
-                    substValue = System.getProperty(variable);
-                }
-            }
-        }
-
-        if (op != null)
-        {
-            if (op.startsWith(":-"))
-            {
-                if (substValue == null || substValue.length() == 0 )
-                {
-                    substValue = op.substring(":-".length());
-                }
-            }
-            else if (op.startsWith(":+"))
-            {
-                if (substValue != null && substValue.length() != 0)
-                {
-                    substValue = op.substring(":+".length());
-                }
-            }
-            else
-            {
-                throw new IllegalArgumentException("Bad substitution: ${" + org + "}");
-            }
-        }
-
-        if (substValue == null)
-        {
-            if (defaultsToEmptyString)
-            {
-                substValue = "";
-            }
-            else
-            {
-                // alters the original token to avoid infinite recursion
-                // altered tokens are reverted in substVarsPreserveUnresolved()
-                substValue = MARKER + "{" + variable + "}";
-            }
-        }
-
-        // Remove the found variable from the cycle map, since
-        // it may appear more than once in the value and we don't
-        // want such situations to appear as a recursive reference.
-        cycleMap.remove(variable);
-
-        // Append the leading characters, the substituted value of
-        // the variable, and the trailing characters to get the new
-        // value.
-        val = val.substring(0, startDelim) + substValue + val.substring(stopDelim + DELIM_STOP.length(), val.length());
-
-        // Now perform substitution again, since there could still
-        // be substitutions to make.
-        val = doSubstVars(val, currentKey, cycleMap, configProps, callback, substituteFromConfig, substituteFromSystemProperties, defaultsToEmptyString);
-
-        cycleMap.remove(currentKey);
-
-        // Return the value.
-        return val;
-    }
-
-    private static String unescape(String val)
-    {
-        val = val.replaceAll("\\" + MARKER, "\\$");
-
-        Matcher existingSubstVarMatcher = EXISTING_SUBST_VAR.matcher(val);
-
-        if (!existingSubstVarMatcher.matches()) {
-            return val;
-        }
-        int escape = indexOf(val, 0);
-        while (escape >= 0 && escape < val.length() - 1)
-        {
-            char c = val.charAt(escape + 1);
-            if (c == '{' || c == '}' || c == ESCAPE_CHAR)
-            {
-                val = val.substring(0, escape) + val.substring(escape + 1);
-            }
-            escape = indexOf(val, escape + 1);
-        }
-        return val;
-    }
-
-    private static int indexOf(String val, int fromIndex) {
-        Matcher escapedOpeningCurlyMatcher = ESCAPED_OPENING_CURLY.matcher(val);
-
-        Matcher escapedClosingCurlyMatcher = ESCAPED_CLOSING_CURLY.matcher(val);
-
-        int escapedOpeningCurlyMatcherIndex = escapedOpeningCurlyMatcher.find(fromIndex) ? escapedOpeningCurlyMatcher.start() : Integer.MAX_VALUE;
-        int escapedClosingCurlyMatcherIndex = escapedClosingCurlyMatcher.find(fromIndex) ? escapedClosingCurlyMatcher.start() : Integer.MAX_VALUE;
-
-        int indexOf = Math.min(escapedOpeningCurlyMatcherIndex, escapedClosingCurlyMatcherIndex);
-
-        return indexOf == Integer.MAX_VALUE ? -1 : indexOf;
-    }
-
-    public static class BundleContextSubstitutionCallback implements SubstitutionCallback
-    {
-        private final BundleContext context;
-
-        public BundleContextSubstitutionCallback(BundleContext context)
-        {
-            this.context = context;
-        }
-
-        public String getValue(String key)
-        {
-            String value = null;
-            if (key.startsWith(ENV_PREFIX))
-            {
-                value = System.getenv(key.substring(ENV_PREFIX.length()));
-            }
-            else
-            {
-                if (context != null)
-                {
-                    value = context.getProperty(key);
-                }
-                if (value == null)
-                {
-                    value = System.getProperty(key);
-                }
-            }
-            return value;
-        }
-    }
+	/**
+	 * Perform substitution on a property set
+	 *
+	 * @param properties the property set to perform substitution on
+	 */
+	public static void performSubstitution(Map<String, String> properties) {
+		performSubstitution(properties, (BundleContext)null);
+	}
+
+	/**
+	 * Perform substitution on a property set
+	 *
+	 * @param properties the property set to perform substitution on
+	 * @param bundleContext The bundle context
+	 */
+	public static void performSubstitution(
+		Map<String, String> properties, BundleContext bundleContext) {
+
+		performSubstitution(
+			properties, new BundleContextSubstitutionCallback(bundleContext));
+	}
+
+	/**
+	 * Perform substitution on a property set
+	 *
+	 * @param properties the property set to perform substitution on
+	 * @param substitutionCallback Callback for substituion
+	 */
+	public static void performSubstitution(
+		Map<String, String> properties,
+		SubstitutionCallback substitutionCallback) {
+
+		performSubstitution(properties, substitutionCallback, true, true, true);
+	}
+
+	/**
+	 * Perform substitution on a property set
+	 *
+	 * @param properties the property set to perform substitution on
+	 * @param callback the callback to obtain substitution values
+	 * @param substituteFromConfig If substitute from configuration
+	 * @param substituteFromSystemProperties If substitute from system properties
+	 * @param defaultsToEmptyString sets an empty string if a replacement value is not found, leaves intact otherwise
+	 */
+	public static void performSubstitution(
+		Map<String, String> properties, SubstitutionCallback callback,
+		boolean substituteFromConfig, boolean substituteFromSystemProperties,
+		boolean defaultsToEmptyString) {
+
+		Map<String, String> map = new HashMap<>(properties);
+
+		for (Map.Entry<String, String> entry : properties.entrySet()) {
+			String name = entry.getKey();
+
+			properties.put(
+				name,
+				substVars(
+					entry.getValue(), name, null, map, callback,
+					substituteFromConfig, substituteFromSystemProperties,
+					defaultsToEmptyString));
+		}
+	}
+
+	/**
+	 * <p>
+	 * This method performs property variable substitution on the
+	 * specified value. If the specified value contains the syntax
+	 * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
+	 * refers to either a configuration property or a system property,
+	 * then the corresponding property value is substituted for the variable
+	 * placeholder. Multiple variable placeholders may exist in the
+	 * specified value as well as nested variable placeholders, which
+	 * are substituted from inner most to outer most. Configuration
+	 * properties override system properties.
+	 * </p>
+	 *
+	 * @param value The string on which to perform property substitution.
+	 * @param currentKey The key of the property being evaluated used to
+	 *		detect cycles.
+	 * @param cycleMap Map of variable references used to detect nested cycles.
+	 * @param configProps Set of configuration properties.
+	 * @return The value of the specified string after system property substitution.
+	 * @throws IllegalArgumentException If there was a syntax error in the
+	 *		 property placeholder syntax or a recursive variable reference.
+	 **/
+	public static String substVars(
+			String value, String currentKey, Map<String, String> cycleMap,
+			Map<String, String> configProps)
+		throws IllegalArgumentException {
+
+		return substVars(
+			value, currentKey, cycleMap, configProps,
+			(SubstitutionCallback)null);
+	}
+
+	/**
+	 * <p>
+	 * This method performs property variable substitution on the
+	 * specified value. If the specified value contains the syntax
+	 * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
+	 * refers to either a configuration property or a system property,
+	 * then the corresponding property value is substituted for the variable
+	 * placeholder. Multiple variable placeholders may exist in the
+	 * specified value as well as nested variable placeholders, which
+	 * are substituted from inner most to outer most. Configuration
+	 * properties override system properties.
+	 * </p>
+	 *
+	 * @param value The string on which to perform property substitution.
+	 * @param currentKey The key of the property being evaluated used to
+	 *		detect cycles.
+	 * @param cycleMap Map of variable references used to detect nested cycles.
+	 * @param configProps Set of configuration properties.
+	 * @param bundleContext the bundle context to retrieve properties from
+	 * @return The value of the specified string after system property substitution.
+	 * @throws IllegalArgumentException If there was a syntax error in the
+	 *		 property placeholder syntax or a recursive variable reference.
+	 **/
+	public static String substVars(
+			String value, String currentKey, Map<String, String> cycleMap,
+			Map<String, String> configProps, BundleContext bundleContext)
+		throws IllegalArgumentException {
+
+		return substVars(
+			value, currentKey, cycleMap, configProps,
+			new BundleContextSubstitutionCallback(bundleContext));
+	}
+
+	/**
+	 * <p>
+	 * This method performs property variable substitution on the
+	 * specified value. If the specified value contains the syntax
+	 * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
+	 * refers to either a configuration property or a system property,
+	 * then the corresponding property value is substituted for the variable
+	 * placeholder. Multiple variable placeholders may exist in the
+	 * specified value as well as nested variable placeholders, which
+	 * are substituted from inner most to outer most. Configuration
+	 * properties override system properties.
+	 * </p>
+	 *
+	 * @param value The string on which to perform property substitution.
+	 * @param currentKey The key of the property being evaluated used to
+	 *		detect cycles.
+	 * @param cycleMap Map of variable references used to detect nested cycles.
+	 * @param configProps Set of configuration properties.
+	 * @param callback the callback to obtain substitution values
+	 * @return The value of the specified string after system property substitution.
+	 * @throws IllegalArgumentException If there was a syntax error in the
+	 *		 property placeholder syntax or a recursive variable reference.
+	 **/
+	public static String substVars(
+			String value, String currentKey, Map<String, String> cycleMap,
+			Map<String, String> configProps, SubstitutionCallback callback)
+		throws IllegalArgumentException {
+
+		return substVars(
+			value, currentKey, cycleMap, configProps, callback, true, true,
+			true);
+	}
+
+	/**
+	 * <p>
+	 * This method performs property variable substitution on the
+	 * specified value. If the specified value contains the syntax
+	 * <tt>${&lt;prop-name&gt;}</tt>, where <tt>&lt;prop-name&gt;</tt>
+	 * refers to either a configuration property or a system property,
+	 * then the corresponding property value is substituted for the variable
+	 * placeholder. Multiple variable placeholders may exist in the
+	 * specified value as well as nested variable placeholders, which
+	 * are substituted from inner most to outer most. Configuration
+	 * properties override system properties.
+	 * </p>
+	 *
+	 * @param value The string on which to perform property substitution.
+	 * @param currentKey The key of the property being evaluated used to
+	 *		detect cycles.
+	 * @param cycleMap Map of variable references used to detect nested cycles.
+	 * @param configProps Set of configuration properties.
+	 * @param callback the callback to obtain substitution values
+	 * @param substituteFromConfig If substitute from configuration
+	 * @param substituteFromSystemProperties If substitute from system properties
+	 * @param defaultsToEmptyString sets an empty string if a replacement value is not found, leaves intact otherwise
+	 * @return The value of the specified string after system property substitution.
+	 * @throws IllegalArgumentException If there was a syntax error in the
+	 *		 property placeholder syntax or a recursive variable reference.
+	 **/
+	public static String substVars(
+			String value, String currentKey, Map<String, String> cycleMap,
+			Map<String, String> configProps, SubstitutionCallback callback,
+			boolean substituteFromConfig,
+			boolean substituteFromSystemProperties,
+			boolean defaultsToEmptyString)
+		throws IllegalArgumentException {
+
+		return _unescape(
+			_substVars(
+				value, currentKey, cycleMap, configProps, callback,
+				substituteFromConfig, substituteFromSystemProperties,
+				defaultsToEmptyString));
+	}
+
+	public static class BundleContextSubstitutionCallback
+		implements SubstitutionCallback {
+
+		public BundleContextSubstitutionCallback(BundleContext context) {
+			_bundleContext = context;
+		}
+
+		@Override
+		public String getValue(String key) {
+			String value = null;
+
+			if (key.startsWith(_ENV_PREFIX)) {
+				value = System.getenv(key.substring(_ENV_PREFIX.length()));
+			}
+			else {
+				if (_bundleContext != null) {
+					value = _bundleContext.getProperty(key);
+				}
+
+				if (value == null) {
+					value = System.getProperty(key);
+				}
+			}
+
+			return value;
+		}
+
+		private final BundleContext _bundleContext;
+
+	}
+
+	/**
+	 * Callback for substitution
+	 */
+	public interface SubstitutionCallback {
+
+		public String getValue(String key);
+
+	}
+
+	private static int _indexOf(String value, int fromIndex) {
+		Matcher escapedOpeningCurlyMatcher = _escapedOpeningCurly.matcher(
+			value);
+
+		Matcher escapedClosingCurlyMatcher = _escapedClosingCurly.matcher(
+			value);
+
+		int escapedOpeningCurlyMatcherIndex = -1;
+
+		if (escapedOpeningCurlyMatcher.find(fromIndex)) {
+			escapedOpeningCurlyMatcherIndex =
+				escapedOpeningCurlyMatcher.start();
+		}
+
+		int escapedClosingCurlyMatcherIndex = -1;
+
+		if (escapedClosingCurlyMatcher.find(fromIndex)) {
+			escapedClosingCurlyMatcherIndex =
+				escapedClosingCurlyMatcher.start();
+		}
+
+		int index = Math.min(
+			escapedOpeningCurlyMatcherIndex, escapedClosingCurlyMatcherIndex);
+
+		if (index == Integer.MAX_VALUE) {
+			return -1;
+		}
+
+		return index;
+	}
+
+	private static String _substVars(
+			String value, String currentKey, Map<String, String> cycleMap,
+			Map<String, String> configProps, SubstitutionCallback callback,
+			boolean substituteFromConfig,
+			boolean substituteFromSystemProperties,
+			boolean defaultsToEmptyString)
+		throws IllegalArgumentException {
+
+		if (cycleMap == null) {
+			cycleMap = new HashMap<>();
+		}
+
+		// Put the current key in the cycle map.
+
+		cycleMap.put(currentKey, currentKey);
+
+		// Assume we have a value that is something like:
+		// "leading ${foo.${bar}} middle ${baz} trailing"
+
+		// Find the first ending '}' variable delimiter, which
+		// will correspond to the first deepest nested variable
+		// placeholder.
+
+		int startDelim = value.indexOf(_DELIM_START);
+		int stopDelim = value.indexOf(_DELIM_STOP);
+
+		while ((startDelim >= 0) && (stopDelim >= 0)) {
+			while ((stopDelim > 0) &&
+				   (value.charAt(stopDelim - 1) == _ESCAPE_CHAR)) {
+
+				stopDelim = value.indexOf(_DELIM_STOP, stopDelim + 1);
+			}
+
+			// Find the matching starting "${" variable delimiter
+			// by looping until we find a start delimiter that is
+			// greater than the stop delimiter we have found.
+
+			while (stopDelim >= 0) {
+				int index = value.indexOf(
+					_DELIM_START, startDelim + _DELIM_START.length());
+
+				if ((index < 0) || (index > stopDelim)) {
+					break;
+				}
+				else if (index < stopDelim) {
+					startDelim = index;
+				}
+			}
+
+			if (startDelim < stopDelim) {
+				break;
+			}
+
+			stopDelim = value.indexOf(_DELIM_STOP, stopDelim + 1);
+			startDelim = value.indexOf(_DELIM_START);
+		}
+
+		// If we do not have a start or stop delimiter, then just
+		// return the existing value.
+
+		if ((startDelim < 0) || (stopDelim < 0)) {
+			cycleMap.remove(currentKey);
+
+			return value;
+		}
+
+		// At this point, we have found a variable placeholder so
+		// we must perform a variable substitution on it.
+		// Using the start and stop delimiter indices, extract
+		// the first, deepest nested variable placeholder.
+
+		String variable = value.substring(
+			startDelim + _DELIM_START.length(), stopDelim);
+
+		String original = variable;
+
+		// Strip expansion modifiers
+
+		int index1 = variable.lastIndexOf(":-");
+		int index2 = variable.lastIndexOf(":+");
+
+		int index = -1;
+
+		if ((index1 >= 0) && (index2 >= 0)) {
+			index = Math.min(index1, index1);
+		}
+		else if (index1 >= 0) {
+			index = index1;
+		}
+		else {
+			index = index2;
+		}
+
+		String op = null;
+
+		if ((index >= 0) && (index < variable.length())) {
+			op = variable.substring(index);
+
+			variable = variable.substring(0, index);
+		}
+
+		// Verify that this is not a recursive variable reference.
+
+		if (cycleMap.get(variable) != null) {
+			throw new IllegalArgumentException(
+				"recursive variable reference: " + variable);
+		}
+
+		String substValue = null;
+
+		// Get the value of the deepest nested variable placeholder.
+		// Try to configuration properties first.
+
+		if (substituteFromConfig && (configProps != null)) {
+			substValue = configProps.get(variable);
+		}
+
+		if ((substValue == null) && (variable.length() > 0)) {
+			if (callback != null) {
+				substValue = callback.getValue(variable);
+			}
+
+			if ((substValue == null) && substituteFromSystemProperties) {
+				substValue = System.getProperty(variable);
+			}
+		}
+
+		if (op != null) {
+			if (op.startsWith(":-")) {
+				if ((substValue == null) || (substValue.length() == 0)) {
+					substValue = op.substring(":-".length());
+				}
+			}
+			else if (op.startsWith(":+")) {
+				if ((substValue != null) && (substValue.length() != 0)) {
+					substValue = op.substring(":+".length());
+				}
+			}
+			else {
+				throw new IllegalArgumentException(
+					"Bad substitution: ${" + original + "}");
+			}
+		}
+
+		if (substValue == null) {
+			if (defaultsToEmptyString) {
+				substValue = "";
+			}
+			else {
+
+				// alters the original token to avoid infinite recursion
+				// altered tokens are reverted in substVarsPreserveUnresolved()
+
+				substValue = _MARKER + "{" + variable + "}";
+			}
+		}
+
+		// Remove the found variable from the cycle map, since
+		// it may appear more than once in the value and we don't
+		// want such situations to appear as a recursive reference.
+
+		cycleMap.remove(variable);
+
+		// Append the leading characters, the substituted value of
+		// the variable, and the trailing characters to get the new
+		// value.
+
+		value =
+			value.substring(0, startDelim) + substValue +
+				value.substring(stopDelim + _DELIM_STOP.length());
+
+		// Now perform substitution again, since there could still
+		// be substitutions to make.
+
+		value = _substVars(
+			value, currentKey, cycleMap, configProps, callback,
+			substituteFromConfig, substituteFromSystemProperties,
+			defaultsToEmptyString);
+
+		cycleMap.remove(currentKey);
+
+		// Return the value.
+
+		return value;
+	}
+
+	private static String _unescape(String value) {
+		value = value.replaceAll("\\" + _MARKER, "\\$");
+
+		Matcher existingSubstVarMatcher = _existingSubstVar.matcher(value);
+
+		if (!existingSubstVarMatcher.matches()) {
+			return value;
+		}
+
+		int escape = _indexOf(value, 0);
+
+		while ((escape >= 0) && (escape < (value.length() - 1))) {
+			char c = value.charAt(escape + 1);
+
+			if ((c == '{') || (c == '}') || (c == _ESCAPE_CHAR)) {
+				value =
+					value.substring(0, escape) + value.substring(escape + 1);
+			}
+
+			escape = _indexOf(value, escape + 1);
+		}
+
+		return value;
+	}
+
+	private InterpolationHelper() {
+	}
+
+	private static final String _DELIM_START = "${";
+
+	private static final String _DELIM_STOP = "}";
+
+	private static final String _ENV_PREFIX = "env:";
+
+	private static final char _ESCAPE_CHAR = '\\';
+
+	private static final String _MARKER = "$__";
+
+	private static final Pattern _escapedClosingCurly = Pattern.compile(
+		"\\\\+\\}");
+	private static final Pattern _escapedOpeningCurly = Pattern.compile(
+		"\\\\+\\{");
+	private static final Pattern _existingSubstVar = Pattern.compile(
+		".*\\$\\\\*\\{.*\\}.*");
 
 }
 /* @generated */
\ No newline at end of file
diff --git a/org/apache/felix/utils/properties/Properties.java b/org/apache/felix/utils/properties/Properties.java
index 808b0e0..123d825 100644
--- a/org/apache/felix/utils/properties/Properties.java
+++ b/org/apache/felix/utils/properties/Properties.java
@@ -6,7 +6,7 @@
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *	  http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.felix.utils.properties;
 
 import java.io.File;
@@ -28,9 +29,9 @@ import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.io.Writer;
+
 import java.net.URL;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+
 import java.util.AbstractMap;
 import java.util.AbstractSet;
 import java.util.ArrayList;
@@ -42,6 +43,8 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import org.osgi.framework.BundleContext;
 
@@ -55,1190 +58,1397 @@ import org.osgi.framework.BundleContext;
  */
 public class Properties extends AbstractMap<String, String> {
 
-    /** Constant for the supported comment characters.*/
-    private static final String COMMENT_CHARS = "#!";
-
-    /** The list of possible key/value separators */
-    private static final char[] SEPARATORS = new char[] {'=', ':'};
-
-    /** The white space characters used as key/value separators. */
-    private static final char[] WHITE_SPACE = new char[] {' ', '\t', '\f'};
-
-    /**
-     * The default encoding (ISO-8859-1 as specified by
-     * http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html)
-     */
-    static final String DEFAULT_ENCODING = "ISO-8859-1";
-
-    /** Constant for the platform specific line separator.*/
-    private static final String LINE_SEPARATOR = AccessController.doPrivileged(new PrivilegedAction<String>() {
-            public String run() {
-                return System.getProperty("line.separator");
-            }
-        });
-
-    /** Constant for the radix of hex numbers.*/
-    private static final int HEX_RADIX = 16;
-
-    /** Constant for the length of a unicode literal.*/
-    private static final int UNICODE_LEN = 4;
-
-    private final Map<String,String> storage = new LinkedHashMap<String,String>();
-    private final Map<String,Layout> layout = new LinkedHashMap<String,Layout>();
-    private List<String> header;
-    private List<String> footer;
-    private File location;
-    private InterpolationHelper.SubstitutionCallback callback;
-    boolean substitute = true;
-    boolean typed;
-
-    public Properties() {
-    }
-
-    public Properties(File location) throws IOException {
-      this(location, (InterpolationHelper.SubstitutionCallback) null);
-    }
-
-    public Properties(File location, BundleContext context) throws IOException {
-        this(location, new InterpolationHelper.BundleContextSubstitutionCallback(context));
-    }
-
-    public Properties(File location, InterpolationHelper.SubstitutionCallback callback) throws IOException {
-        this.location = location;
-        this.callback = callback;
-        if(location.exists())
-            load(location);
-    }
-
-    public Properties(boolean substitute) {
-        this.substitute = substitute;
-    }
-
-    public Properties(File location, boolean substitute) {
-        this.location = location;
-        this.substitute = substitute;
-    }
-
-    public void load(File location) throws IOException {
-        InputStream is = new FileInputStream(location);
-        try {
-            load(is);
-        } finally {
-            is.close();
-        }
-    }
-
-    public void load(URL location) throws IOException {
-        InputStream is = location.openStream();
-        try {
-            load(is);
-        } finally {
-            is.close();
-        }
-    }
-
-    public void load(InputStream is) throws IOException {
-        load(new InputStreamReader(is, DEFAULT_ENCODING));
-    }
-
-    public void load(Reader reader) throws IOException {
-        loadLayout(reader, false);
-    }
-
-    public void save() throws IOException {
-        save(this.location);
-    }
-
-    public void save(File location) throws IOException {
-        OutputStream os = new FileOutputStream(location);
-        try {
-            save(os);
-        } finally {
-            os.close();
-        }
-    }
-
-    public void save(OutputStream os) throws IOException {
-        save(new OutputStreamWriter(os, DEFAULT_ENCODING));
-    }
-
-    public void save(Writer writer) throws IOException {
-        saveLayout(writer, typed);
-    }
-
-    /**
-     * Store a properties into a output stream, preserving comments, special character, etc.
-     * This method is mainly to be compatible with the java.util.Properties class.
-     *
-     * @param os an output stream.
-     * @param comment this parameter is ignored as this Properties
-     * @throws IOException If storing fails
-     */
-    public void store(OutputStream os, String comment) throws IOException {
-        this.save(os);
-    }
-
-    /**
-     * Searches for the property with the specified key in this property list.
-     *
-     * @param key the property key.
-     * @return the value in this property list with the specified key value.
-     */
-    public String getProperty(String key) {
-        return this.get(key);
-    }
-
-    /**
-     * Searches for the property with the specified key in this property list. If the key is not found in this property
-     * list, the default property list, and its defaults, recursively, are then checked. The method returns the default
-     * value argument if the property is not found.
-     *
-     * @param key the property key.
-     * @param defaultValue a default value.
-     * @return The property value of the default value
-     */
-    public String getProperty(String key, String defaultValue) {
-        if (this.get(key) != null)
-            return this.get(key);
-        return defaultValue;
-    }
-
-    @Override
-    public Set<Entry<String, String>> entrySet() {
-        return new AbstractSet<Entry<String, String>>() {
-            @Override
-            public Iterator<Entry<String, String>> iterator() {
-                return new Iterator<Entry<String, String>>() {
-                    final Iterator<Entry<String, String>> keyIterator = storage.entrySet().iterator();
-                    public boolean hasNext() {
-                        return keyIterator.hasNext();
-                    }
-                    public Entry<String, String> next() {
-                        final Entry<String, String> entry = keyIterator.next();
-                        return new Entry<String, String>() {
-                            public String getKey() {
-                                return entry.getKey();
-                            }
-                            public String getValue() {
-                                return entry.getValue();
-                            }
-                            public String setValue(String value) {
-                                String old = entry.setValue(value);
-                                if (old == null || !old.equals(value)) {
-                                    Layout l = layout.get(entry.getKey());
-                                    if (l != null) {
-                                        l.clearValue();
-                                    }
-                                }
-                                return old;
-                            }
-                        };
-                    }
-                    public void remove() {
-                        keyIterator.remove();
-                    }
-                };
-            }
-
-            @Override
-            public int size() {
-                return storage.size();
-            }
-        };
-    }
-
-    /**
-     * Returns an enumeration of all the keys in this property list, including distinct keys in the default property
-     * list if a key of the same name has not already been found from the main properties list.
-     *
-     * @return an enumeration of all the keys in this property list, including the keys in the default property list.
-     */
-    public Enumeration<?> propertyNames() {
-        return Collections.enumeration(storage.keySet());
-    }
-
-    /**
-     * Calls the map method put. Provided for parallelism with the getProperty method.
-     * Enforces use of strings for property keys and values. The value returned is the result of the map call to put.
-     *
-     * @param key the key to be placed into this property list.
-     * @param value the value corresponding to the key.
-     * @return the previous value of the specified key in this property list, or null if it did not have one.
-     */
-    public Object setProperty(String key, String value) {
-        return this.put(key, value);
-    }
-
-    @Override
-    public String put(String key, String value) {
-        String old = storage.put(key, value);
-        if (old == null || !old.equals(value)) {
-            Layout l = layout.get(key);
-            if (l != null) {
-                l.clearValue();
-            }
-        }
-        return old;
-    }
-
-    void putAllSubstituted(Map<? extends String, ? extends String> m) {
-        storage.putAll(m);
-    }
-
-    public String put(String key, List<String> commentLines, List<String> valueLines) {
-        commentLines = new ArrayList<String>(commentLines);
-        valueLines = new ArrayList<String>(valueLines);
-        String escapedKey = escapeKey(key);
-        StringBuilder sb = new StringBuilder();
-        int lastLine = valueLines.size() - 1;
-        if (valueLines.isEmpty()) {
-            valueLines.add(escapedKey + "=");
-            sb.append(escapedKey).append("=");
-        } else {
-            String val0 = valueLines.get(0);
-            String rv0 = typed ? val0 : escapeJava(val0);
-            if (!val0.trim().startsWith(escapedKey)) {
-                valueLines.set(0, escapedKey + " = " + rv0 /*+ (0 < lastLine? "\\": "")*/);
-                sb.append(escapedKey).append(" = ").append(rv0);
-            } else {
-                valueLines.set(0, rv0 /*+ (0 < lastLine? "\\": "")*/);
-                sb.append(rv0);
-            }
-        }
-        for (int i = 1; i < valueLines.size(); i++) {
-            String val = valueLines.get(i);
-            valueLines.set(i, typed ? val : escapeJava(val) /*+ (i < lastLine? "\\": "")*/);
-            while (val.length() > 0 && Character.isWhitespace(val.charAt(0))) {
-                val = val.substring(1);
-            }
-            sb.append(val);
-        }
-        String[] property = PropertiesReader.parseProperty(sb.toString());
-        this.layout.put(key, new Layout(commentLines, valueLines));
-        return storage.put(key, property[1]);
-    }
-
-    public String put(String key, List<String> commentLines, String value) {
-        commentLines = new ArrayList<String>(commentLines);
-        this.layout.put(key, new Layout(commentLines, null));
-        return storage.put(key, value);
-    }
-
-    public String put(String key, String comment, String value) {
-        return put(key, Collections.singletonList(comment), value);
-    }
-
-    public boolean update(Map<String, String> props) {
-        Properties properties;
-        if (props instanceof Properties) {
-            properties = (Properties) props;
-        } else {
-            properties = new Properties();
-            for (Map.Entry<? extends String, ? extends String> e : props.entrySet()) {
-                properties.put(e.getKey(), e.getValue());
-            }
-        }
-        return update(properties);
-    }
-
-    public boolean update(Properties properties) {
-        boolean modified = false;
-        // Remove "removed" properties from the cfg file
-        for (String key : new ArrayList<String>(this.keySet())) {
-            if (!properties.containsKey(key)) {
-                this.remove(key);
-                modified = true;
-            }
-        }
-        // Update existing keys
-        for (String key : properties.keySet()) {
-            String v = this.get(key);
-            List<String> comments = properties.getComments(key);
-            List<String> value = properties.getRaw(key);
-            if (v == null) {
-                this.put(key, comments, value);
-                modified = true;
-            } else if (!v.equals(properties.get(key))) {
-                if (comments.isEmpty()) {
-                    comments = this.getComments(key);
-                }
-                this.put(key, comments, value);
-                modified = true;
-            }
-        }
-        return modified;
-    }
-
-    public List<String> getRaw(String key) {
-        if (layout.containsKey(key)) {
-            if (layout.get(key).getValueLines() != null) {
-                return new ArrayList<String>(layout.get(key).getValueLines());
-            }
-        }
-        List<String> result = new ArrayList<String>();
-        if (storage.containsKey(key)) {
-            result.add(storage.get(key));
-        }
-        return result;
-    }
-
-    public List<String> getComments(String key) {
-        if (layout.containsKey(key)) {
-            if (layout.get(key).getCommentLines() != null) {
-                return new ArrayList<String>(layout.get(key).getCommentLines());
-            }
-        }
-        return new ArrayList<String>();
-    }
-
-    @Override
-    public String remove(Object key) {
-        Layout l = layout.get(key);
-        if (l != null) {
-            l.clearValue();
-        }
-        return storage.remove(key);
-    }
-
-    @Override
-    public void clear() {
-        for (Layout l : layout.values()) {
-            l.clearValue();
-        }
-        storage.clear();
-    }
-
-    /**
-     * Return the comment header.
-     *
-     * @return the comment header
-     */
-    public List<String> getHeader()
-    {
-        return header;
-    }
-
-    /**
-     * Set the comment header.
-     *
-     * @param header the header to use
-     */
-    public void setHeader(List<String> header)
-    {
-        this.header = header;
-    }
-
-    /**
-     * Return the comment footer.
-     *
-     * @return the comment footer
-     */
-    public List<String> getFooter()
-    {
-        return footer;
-    }
-
-    /**
-     * Set the comment footer.
-     *
-     * @param footer the footer to use
-     */
-    public void setFooter(List<String> footer)
-    {
-        this.footer = footer;
-    }
-
-    /**
-     * Reads a properties file and stores its internal structure. The found
-     * properties will be added to the associated configuration object.
-     *
-     * @param in the reader to the properties file
-     * @throws java.io.IOException if an error occurs
-     */
-    protected void loadLayout(Reader in, boolean maybeTyped) throws IOException
-    {
-        PropertiesReader reader = new PropertiesReader(in, maybeTyped);
-        boolean hasProperty = false;
-        while (reader.nextProperty())
-        {
-            hasProperty = true;
-            storage.put(reader.getPropertyName(), reader.getPropertyValue());
-            int idx = checkHeaderComment(reader.getCommentLines());
-            layout.put(reader.getPropertyName(),
-                    new Layout(idx < reader.getCommentLines().size() ?
-                                    new ArrayList<String>(reader.getCommentLines().subList(idx, reader.getCommentLines().size())) :
-                                    null,
-                               new ArrayList<String>(reader.getValueLines())));
-        }
-        typed = maybeTyped && reader.typed != null && reader.typed;
-        if (!typed) {
-            for (Map.Entry<String,String> e : storage.entrySet()) {
-                e.setValue(unescapeJava(e.getValue()));
-            }
-        }
-        if (hasProperty) {
-            footer = new ArrayList<String>(reader.getCommentLines());
-        } else {
-            header = new ArrayList<String>(reader.getCommentLines());
-        }
-        if (substitute)
-        {
-            substitute();
-        }
-    }
-
-    public void substitute()
-    {
-        substitute(callback);
-    }
-
-    public void substitute(InterpolationHelper.SubstitutionCallback callback)
-    {
-        if (callback == null)
-        {
-            callback = new InterpolationHelper.BundleContextSubstitutionCallback(null);
-        }
-        InterpolationHelper.performSubstitution(storage, callback);
-    }
-
-    /**
-     * Writes the properties file to the given writer, preserving as much of its
-     * structure as possible.
-     *
-     * @param out the writer
-     * @throws java.io.IOException if an error occurs
-     */
-    protected void saveLayout(Writer out, boolean typed) throws IOException
-    {
-        PropertiesWriter writer = new PropertiesWriter(out, typed);
-        if (header != null)
-        {
-            for (String s : header)
-            {
-                writer.writeln(s);
-            }
-        }
-
-        for (String key : storage.keySet())
-        {
-            Layout l = layout.get(key);
-            if (l != null && l.getCommentLines() != null)
-            {
-                for (String s : l.getCommentLines())
-                {
-                    writer.writeln(s);
-                }
-            }
-            if (l != null && l.getValueLines() != null)
-            {
-                for (int i = 0; i < l.getValueLines().size(); i++)
-                {
-                    String s = l.getValueLines().get(i);
-                    if (i < l.getValueLines().size() - 1)
-                    {
-                        writer.writeln(s + "\\");
-                    }
-                    else
-                    {
-                        writer.writeln(s);
-                    }
-                }
-            }
-            else
-            {
-                writer.writeProperty(key, storage.get(key));
-            }
-        }
-        if (footer != null)
-        {
-            for (String s : footer)
-            {
-                writer.writeln(s);
-            }
-        }
-        writer.flush();
-    }
-
-    /**
-     * Checks if parts of the passed in comment can be used as header comment.
-     * This method checks whether a header comment can be defined (i.e. whether
-     * this is the first comment in the loaded file). If this is the case, it is
-     * searched for the lates blank line. This line will mark the end of the
-     * header comment. The return value is the index of the first line in the
-     * passed in list, which does not belong to the header comment.
-     *
-     * @param commentLines the comment lines
-     * @return the index of the next line after the header comment
-     */
-    private int checkHeaderComment(List<String> commentLines)
-    {
-        if (getHeader() == null && layout.isEmpty())
-        {
-            // This is the first comment. Search for blank lines.
-            int index = commentLines.size() - 1;
-            while (index >= 0 && commentLines.get(index).length() > 0)
-            {
-                index--;
-            }
-            setHeader(new ArrayList<String>(commentLines.subList(0, index + 1)));
-            return index + 1;
-        }
-        else
-        {
-            return 0;
-        }
-    }
-
-    /**
-     * Tests whether a line is a comment, i.e. whether it starts with a comment
-     * character.
-     *
-     * @param line the line
-     * @return a flag if this is a comment line
-     */
-    static boolean isCommentLine(String line) {
-        String s = line.trim();
-        // blank lines are also treated as comment lines
-        return s.length() < 1 || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;
-    }
-
-    /**
-     * <p>Unescapes any Java literals found in the <code>String</code> to a
-     * <code>Writer</code>.</p> This is a slightly modified version of the
-     * StringEscapeUtils.unescapeJava() function in commons-lang that doesn't
-     * drop escaped separators (i.e '\,').
-     *
-     * @param str  the <code>String</code> to unescape, may be null
-     * @return the processed string
-     * @throws IllegalArgumentException if the Writer is <code>null</code>
-     */
-    protected static String unescapeJava(String str) {
-        if (str == null) {
-            return null;
-        }
-        int sz = str.length();
-        StringBuffer out = new StringBuffer(sz);
-        StringBuffer unicode = new StringBuffer(UNICODE_LEN);
-        boolean hadSlash = false;
-        boolean inUnicode = false;
-        for (int i = 0; i < sz; i++) {
-            char ch = str.charAt(i);
-            if (inUnicode) {
-                // if in unicode, then we're reading unicode
-                // values in somehow
-                unicode.append(ch);
-                if (unicode.length() == UNICODE_LEN) {
-                    // unicode now contains the four hex digits
-                    // which represents our unicode character
-                    try {
-                        int value = Integer.parseInt(unicode.toString(), HEX_RADIX);
-                        out.append((char) value);
-                        unicode.setLength(0);
-                        inUnicode = false;
-                        hadSlash = false;
-                    } catch (NumberFormatException nfe) {
-                        throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);
-                    }
-                }
-                continue;
-            }
-
-            if (hadSlash) {
-                // handle an escaped value
-                hadSlash = false;
-                switch (ch) {
-                    case '\\' :
-                        out.append('\\');
-                        break;
-                    case '\'' :
-                        out.append('\'');
-                        break;
-                    case '\"' :
-                        out.append('"');
-                        break;
-                    case 'r' :
-                        out.append('\r');
-                        break;
-                    case 'f' :
-                        out.append('\f');
-                        break;
-                    case 't' :
-                        out.append('\t');
-                        break;
-                    case 'n' :
-                        out.append('\n');
-                        break;
-                    case 'b' :
-                        out.append('\b');
-                        break;
-                    case 'u' :
-                        // uh-oh, we're in unicode country....
-                        inUnicode = true;
-                        break;
-                    default :
-                        out.append(ch);
-                        break;
-                }
-                continue;
-            } else if (ch == '\\') {
-                hadSlash = true;
-                continue;
-            }
-            out.append(ch);
-        }
-
-        if (hadSlash) {
-            // then we're in the weird case of a \ at the end of the
-            // string, let's output it anyway.
-            out.append('\\');
-        }
-
-        return out.toString();
-    }
-
-    /**
-     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>
-     *
-     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
-     *
-     * <p>So a tab becomes the characters <code>'\\'</code> and
-     * <code>'t'</code>.</p>
-     *
-     * <p>The only difference between Java strings and JavaScript strings
-     * is that in JavaScript, a single quote must be escaped.</p>
-     *
-     * <p>Example:</p>
-     * <pre>
-     * input string: He didn't say, "Stop!"
-     * output string: He didn't say, \"Stop!\"
-     * </pre>
-     *
-     *
-     * @param str  String to escape values in, may be null
-     * @return String with escaped values, <code>null</code> if null string input
-     */
-    protected static String escapeJava(String str) {
-        if (str == null) {
-            return null;
-        }
-        int sz = str.length();
-        StringBuffer out = new StringBuffer(sz * 2);
-        for (int i = 0; i < sz; i++) {
-            char ch = str.charAt(i);
-            // handle unicode
-            if (ch > 0xfff) {
-                out.append("\\u").append(hex(ch));
-            } else if (ch > 0xff) {
-                out.append("\\u0").append(hex(ch));
-            } else if (ch > 0x7f) {
-                out.append("\\u00").append(hex(ch));
-            } else if (ch < 32) {
-                switch (ch) {
-                    case '\b' :
-                        out.append('\\');
-                        out.append('b');
-                        break;
-                    case '\n' :
-                        out.append('\\');
-                        out.append('n');
-                        break;
-                    case '\t' :
-                        out.append('\\');
-                        out.append('t');
-                        break;
-                    case '\f' :
-                        out.append('\\');
-                        out.append('f');
-                        break;
-                    case '\r' :
-                        out.append('\\');
-                        out.append('r');
-                        break;
-                    default :
-                        if (ch > 0xf) {
-                            out.append("\\u00").append(hex(ch));
-                        } else {
-                            out.append("\\u000").append(hex(ch));
-                        }
-                        break;
-                }
-            } else {
-                switch (ch) {
-                    case '"' :
-                        out.append('\\');
-                        out.append('"');
-                        break;
-                    case '\\' :
-                        out.append('\\');
-                        out.append('\\');
-                        break;
-                    default :
-                        out.append(ch);
-                        break;
-                }
-            }
-        }
-        return out.toString();
-    }
-
-    /**
-     * <p>Returns an upper case hexadecimal <code>String</code> for the given
-     * character.</p>
-     *
-     * @param ch The character to convert.
-     * @return An upper case hexadecimal <code>String</code>
-     */
-    protected static String hex(char ch) {
-        return Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);
-    }
-
-    /**
-     * <p>Checks if the value is in the given array.</p>
-     *
-     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
-     *
-     * @param array  the array to search through
-     * @param valueToFind  the value to find
-     * @return <code>true</code> if the array contains the object
-     */
-    public static boolean contains(char[] array, char valueToFind) {
-        if (array == null) {
-            return false;
-        }
-        for (int i = 0; i < array.length; i++) {
-            if (valueToFind == array[i]) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Escape the separators in the key.
-     *
-     * @param key the key
-     * @return the escaped key
-     */
-    private static String escapeKey(String key)
-    {
-        StringBuffer newkey = new StringBuffer();
-
-        for (int i = 0; i < key.length(); i++)
-        {
-            char c = key.charAt(i);
-
-            if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c))
-            {
-                // escape the separator
-                newkey.append('\\');
-                newkey.append(c);
-            }
-            else
-            {
-                newkey.append(c);
-            }
-        }
-
-        return newkey.toString();
-    }
-
-    /**
-     * This class is used to read properties lines. These lines do
-     * not terminate with new-line chars but rather when there is no
-     * backslash sign a the end of the line.  This is used to
-     * concatenate multiple lines for readability.
-     */
-    public static class PropertiesReader extends LineNumberReader
-    {
-        /** Stores the comment lines for the currently processed property.*/
-        private final List<String> commentLines;
-
-        /** Stores the value lines for the currently processed property.*/
-        private final List<String> valueLines;
-
-        /** Stores the name of the last read property.*/
-        private String propertyName;
-
-        /** Stores the value of the last read property.*/
-        private String propertyValue;
-
-        private boolean maybeTyped;
-
-        /** Stores if the properties are typed or not */
-        Boolean typed;
-
-        /**
-         * Creates a new instance of <code>PropertiesReader</code> and sets
-         * the underlaying reader and the list delimiter.
-         *
-         * @param reader the reader
-         */
-        public PropertiesReader(Reader reader, boolean maybeTyped)
-        {
-            super(reader);
-            commentLines = new ArrayList<String>();
-            valueLines = new ArrayList<String>();
-            this.maybeTyped = maybeTyped;
-        }
-
-        /**
-         * Reads a property line. Returns null if Stream is
-         * at EOF. Concatenates lines ending with "\".
-         * Skips lines beginning with "#" or "!" and empty lines.
-         * The return value is a property definition (<code>&lt;name&gt;</code>
-         * = <code>&lt;value&gt;</code>)
-         *
-         * @return A string containing a property value or null
-         *
-         * @throws java.io.IOException in case of an I/O error
-         */
-        public String readProperty() throws IOException
-        {
-            commentLines.clear();
-            valueLines.clear();
-            StringBuffer buffer = new StringBuffer();
-
-            while (true)
-            {
-                String line = readLine();
-                if (line == null)
-                {
-                    // EOF
-                    return null;
-                }
-
-                if (isCommentLine(line))
-                {
-                    commentLines.add(line);
-                    continue;
-                }
-
-                boolean combine = checkCombineLines(line);
-                if (combine)
-                {
-                    line = line.substring(0, line.length() - 1);
-                }
-                valueLines.add(line);
-                while (line.length() > 0 && contains(WHITE_SPACE, line.charAt(0)))
-                {
-                    line = line.substring(1, line.length());
-                }
-                buffer.append(line);
-                if (!combine)
-                {
-                    break;
-                }
-            }
-            return buffer.toString();
-        }
-
-        /**
-         * Parses the next property from the input stream and stores the found
-         * name and value in internal fields. These fields can be obtained using
-         * the provided getter methods. The return value indicates whether EOF
-         * was reached (<b>false</b>) or whether further properties are
-         * available (<b>true</b>).
-         *
-         * @return a flag if further properties are available
-         * @throws java.io.IOException if an error occurs
-         */
-        public boolean nextProperty() throws IOException
-        {
-            String line = readProperty();
-
-            if (line == null)
-            {
-                return false; // EOF
-            }
-
-            // parse the line
-            String[] property = parseProperty(line);
-            boolean typed = false;
-            if (maybeTyped && property[1].length() >= 2) {
-                typed = property[1].matches("\\s*[TILFDXSCBilfdxscb]?(\\[[\\S\\s]*\\]|\\{[\\S\\s]*\\}|\"[\\S\\s]*\")\\s*");
-            }
-            if (this.typed == null) {
-                this.typed = typed;
-            } else {
-                this.typed = this.typed & typed;
-            }
-            propertyName = unescapeJava(property[0]);
-            propertyValue = property[1];
-            return true;
-        }
-
-        /**
-         * Returns the comment lines that have been read for the last property.
-         *
-         * @return the comment lines for the last property returned by
-         * <code>readProperty()</code>
-         */
-        public List<String> getCommentLines()
-        {
-            return commentLines;
-        }
-
-        /**
-         * Returns the value lines that have been read for the last property.
-         *
-         * @return the raw value lines for the last property returned by
-         * <code>readProperty()</code>
-         */
-        public List<String> getValueLines()
-        {
-            return valueLines;
-        }
-
-        /**
-         * Returns the name of the last read property. This method can be called
-         * after <code>{@link #nextProperty()}</code> was invoked and its
-         * return value was <b>true</b>.
-         *
-         * @return the name of the last read property
-         */
-        public String getPropertyName()
-        {
-            return propertyName;
-        }
-
-        /**
-         * Returns the value of the last read property. This method can be
-         * called after <code>{@link #nextProperty()}</code> was invoked and
-         * its return value was <b>true</b>.
-         *
-         * @return the value of the last read property
-         */
-        public String getPropertyValue()
-        {
-            return propertyValue;
-        }
-
-        /**
-         * Checks if the passed in line should be combined with the following.
-         * This is true, if the line ends with an odd number of backslashes.
-         *
-         * @param line the line
-         * @return a flag if the lines should be combined
-         */
-        private static boolean checkCombineLines(String line)
-        {
-            int bsCount = 0;
-            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\'; idx--)
-            {
-                bsCount++;
-            }
-
-            return bsCount % 2 != 0;
-        }
-
-        /**
-         * Parse a property line and return the key and the value in an array.
-         *
-         * @param line the line to parse
-         * @return an array with the property's key and value
-         */
-        private static String[] parseProperty(String line)
-        {
-            // sorry for this spaghetti code, please replace it as soon as
-            // possible with a regexp when the Java 1.3 requirement is dropped
-
-            String[] result = new String[2];
-            StringBuffer key = new StringBuffer();
-            StringBuffer value = new StringBuffer();
-
-            // state of the automaton:
-            // 0: key parsing
-            // 1: antislash found while parsing the key
-            // 2: separator crossing
-            // 3: white spaces
-            // 4: value parsing
-            int state = 0;
-
-            for (int pos = 0; pos < line.length(); pos++)
-            {
-                char c = line.charAt(pos);
-
-                switch (state)
-                {
-                    case 0:
-                        if (c == '\\')
-                        {
-                            state = 1;
-                        }
-                        else if (contains(WHITE_SPACE, c))
-                        {
-                            // switch to the separator crossing state
-                            state = 2;
-                        }
-                        else if (contains(SEPARATORS, c))
-                        {
-                            // switch to the value parsing state
-                            state = 3;
-                        }
-                        else
-                        {
-                            key.append(c);
-                        }
-
-                        break;
-
-                    case 1:
-                        if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c))
-                        {
-                            // this is an escaped separator or white space
-                            key.append(c);
-                        }
-                        else
-                        {
-                            // another escaped character, the '\' is preserved
-                            key.append('\\');
-                            key.append(c);
-                        }
-
-                        // return to the key parsing state
-                        state = 0;
-
-                        break;
-
-                    case 2:
-                        if (contains(WHITE_SPACE, c))
-                        {
-                            // do nothing, eat all white spaces
-                            state = 2;
-                        }
-                        else if (contains(SEPARATORS, c))
-                        {
-                            // switch to the value parsing state
-                            state = 3;
-                        }
-                        else
-                        {
-                            // any other character indicates we encoutered the beginning of the value
-                            value.append(c);
-
-                            // switch to the value parsing state
-                            state = 4;
-                        }
-
-                        break;
-
-                    case 3:
-                        if (contains(WHITE_SPACE, c))
-                        {
-                            // do nothing, eat all white spaces
-                            state = 3;
-                        }
-                        else
-                        {
-                            // any other character indicates we encoutered the beginning of the value
-                            value.append(c);
-
-                            // switch to the value parsing state
-                            state = 4;
-                        }
-
-                        break;
-
-                    case 4:
-                        value.append(c);
-                        break;
-                }
-            }
-
-            result[0] = key.toString();
-            result[1] = value.toString();
-
-            return result;
-        }
-    } // class PropertiesReader
-
-    /**
-     * This class is used to write properties lines.
-     */
-    public static class PropertiesWriter extends FilterWriter
-    {
-        private boolean typed;
-
-        /**
-         * Constructor.
-         *
-         * @param writer a Writer object providing the underlying stream
-         */
-        public PropertiesWriter(Writer writer, boolean typed)
-        {
-            super(writer);
-            this.typed = typed;
-        }
-
-        /**
-         * Writes the given property and its value.
-         *
-         * @param key the property key
-         * @param value the property value
-         * @throws java.io.IOException if an error occurs
-         */
-        public void writeProperty(String key, String value) throws IOException
-        {
-            write(escapeKey(key));
-            write(" = ");
-            write(typed ? value : escapeJava(value));
-            writeln(null);
-        }
-
-        /**
-         * Helper method for writing a line with the platform specific line
-         * ending.
-         *
-         * @param s the content of the line (may be <b>null</b>)
-         * @throws java.io.IOException if an error occurs
-         */
-        public void writeln(String s) throws IOException
-        {
-            if (s != null)
-            {
-                write(s);
-            }
-            write(LINE_SEPARATOR);
-        }
-
-    } // class PropertiesWriter
-
-    /**
-     * TODO
-     */
-    protected static class Layout {
-
-        private List<String> commentLines;
-        private List<String> valueLines;
-
-        public Layout() {
-        }
-
-        public Layout(List<String> commentLines, List<String> valueLines) {
-            this.commentLines = commentLines;
-            this.valueLines = valueLines;
-        }
-
-        public List<String> getCommentLines() {
-            return commentLines;
-        }
-
-        public void setCommentLines(List<String> commentLines) {
-            this.commentLines = commentLines;
-        }
-
-        public List<String> getValueLines() {
-            return valueLines;
-        }
-
-        public void setValueLines(List<String> valueLines) {
-            this.valueLines = valueLines;
-        }
-
-        public void clearValue() {
-            this.valueLines = null;
-        }
-
-    } // class Layout
+	/**
+	 * The default encoding (ISO-8859-1 as specified by
+	 * http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html)
+	 */
+	public static final String DEFAULT_ENCODING = "ISO-8859-1";
+
+	/**
+	 * <p>Checks if the value is in the given array.</p>
+	 *
+	 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
+	 *
+	 * @param array  the array to search through
+	 * @param valueToFind  the value to find
+	 * @return <code>true</code> if the array contains the object
+	 */
+	public static boolean contains(char[] array, char valueToFind) {
+		if (array == null) {
+			return false;
+		}
+
+		for (int i = 0; i < array.length; i++) {
+			if (valueToFind == array[i]) {
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	public Properties() {
+	}
+
+	public Properties(boolean substitute) {
+		_substitute = substitute;
+	}
+
+	public Properties(File location) throws IOException {
+		this(location, (InterpolationHelper.SubstitutionCallback)null);
+	}
+
+	public Properties(File location, boolean substitute) {
+		_location = location;
+		_substitute = substitute;
+	}
+
+	public Properties(File location, BundleContext context) throws IOException {
+		this(
+			location,
+			new InterpolationHelper.BundleContextSubstitutionCallback(context));
+	}
+
+	public Properties(
+			File location, InterpolationHelper.SubstitutionCallback callback)
+		throws IOException {
+
+		_location = location;
+		_callback = callback;
+
+		if (location.exists()) {
+			load(location);
+		}
+	}
+
+	@Override
+	public void clear() {
+		for (Layout layout : _layoutMap.values()) {
+			layout.clearValue();
+		}
+
+		_storage.clear();
+	}
+
+	@Override
+	public Set<Entry<String, String>> entrySet() {
+		return new AbstractSet<Entry<String, String>>() {
+
+			@Override
+			public Iterator<Entry<String, String>> iterator() {
+				return new KeyIterator();
+			}
+
+			@Override
+			public int size() {
+				return _storage.size();
+			}
+
+		};
+	}
+
+	public List<String> getComments(String key) {
+		Layout layout = _layoutMap.get(key);
+
+		if (layout != null) {
+			List<String> commentLines = layout.getCommentLines();
+
+			if (commentLines != null) {
+				return new ArrayList<>(commentLines);
+			}
+		}
+
+		return new ArrayList<>();
+	}
+
+	/**
+	 * Return the comment footer.
+	 *
+	 * @return the comment footer
+	 */
+	public List<String> getFooter() {
+		return _footer;
+	}
+
+	/**
+	 * Return the comment header.
+	 *
+	 * @return the comment header
+	 */
+	public List<String> getHeader() {
+		return _header;
+	}
+
+	/**
+	 * Searches for the property with the specified key in this property list.
+	 *
+	 * @param key the property key.
+	 * @return the value in this property list with the specified key value.
+	 */
+	public String getProperty(String key) {
+		return get(key);
+	}
+
+	/**
+	 * Searches for the property with the specified key in this property list. If the key is not found in this property
+	 * list, the default property list, and its defaults, recursively, are then checked. The method returns the default
+	 * value argument if the property is not found.
+	 *
+	 * @param key the property key.
+	 * @param defaultValue a default value.
+	 * @return The property value of the default value
+	 */
+	public String getProperty(String key, String defaultValue) {
+		if (get(key) != null) {
+			return get(key);
+		}
+
+		return defaultValue;
+	}
+
+	public List<String> getRaw(String key) {
+		Layout layout = _layoutMap.get(key);
+
+		if (layout != null) {
+			List<String> valueLines = layout.getValueLines();
+
+			if (valueLines != null) {
+				return new ArrayList<>(valueLines);
+			}
+		}
+
+		List<String> result = new ArrayList<>();
+
+		if (_storage.containsKey(key)) {
+			result.add(_storage.get(key));
+		}
+
+		return result;
+	}
+
+	public boolean isTyped() {
+		return _typed;
+	}
+
+	public void load(File location) throws IOException {
+		try (InputStream inputStream = new FileInputStream(location)) {
+			load(inputStream);
+		}
+	}
+
+	public void load(InputStream inputStream) throws IOException {
+		load(new InputStreamReader(inputStream, DEFAULT_ENCODING));
+	}
+
+	public void load(Reader reader) throws IOException {
+		loadLayout(reader, false);
+	}
+
+	public void load(URL url) throws IOException {
+		try (InputStream inputStream = url.openStream()) {
+			load(inputStream);
+		}
+	}
+
+	/**
+	 * Reads a properties file and stores its internal structure. The found
+	 * properties will be added to the associated configuration object.
+	 *
+	 * @param reader the reader to the properties file
+	 * @throws IOException if an error occurs
+	 */
+	public void loadLayout(Reader reader, boolean maybeTyped)
+		throws IOException {
+
+		PropertiesReader propertiesReader = new PropertiesReader(
+			reader, maybeTyped);
+
+		boolean hasProperty = false;
+
+		while (propertiesReader.nextProperty()) {
+			hasProperty = true;
+
+			_storage.put(
+				propertiesReader.getPropertyName(),
+				propertiesReader.getPropertyValue());
+
+			int index = _checkHeaderComment(propertiesReader.getCommentLines());
+
+			List<String> commentLines = propertiesReader.getCommentLines();
+
+			int size = commentLines.size();
+
+			if (index < commentLines.size()) {
+				commentLines = commentLines.subList(index, size);
+			}
+			else {
+				commentLines = null;
+			}
+
+			_layoutMap.put(
+				propertiesReader.getPropertyName(),
+				new Layout(
+					commentLines,
+					new ArrayList<>(propertiesReader.getValueLines())));
+		}
+
+		if (!maybeTyped || !propertiesReader.isTyped()) {
+			_typed = false;
+
+			for (Entry<String, String> entry : _storage.entrySet()) {
+				entry.setValue(_unescapeJava(entry.getValue()));
+			}
+		}
+		else {
+			_typed = true;
+		}
+
+		if (hasProperty) {
+			_footer = new ArrayList<>(propertiesReader.getCommentLines());
+		}
+		else {
+			_header = new ArrayList<>(propertiesReader.getCommentLines());
+		}
+
+		if (_substitute) {
+			substitute();
+		}
+	}
+
+	/**
+	 * Returns an enumeration of all the keys in this property list, including distinct keys in the default property
+	 * list if a key of the same name has not already been found from the main properties list.
+	 *
+	 * @return an enumeration of all the keys in this property list, including the keys in the default property list.
+	 */
+	public Enumeration<?> propertyNames() {
+		return Collections.enumeration(_storage.keySet());
+	}
+
+	public String put(
+		String key, List<String> commentLines, List<String> valueLines) {
+
+		commentLines = new ArrayList<>(commentLines);
+
+		valueLines = new ArrayList<>(valueLines);
+
+		String escapedKey = _escapeKey(key);
+
+		StringBuilder sb = new StringBuilder();
+
+		if (valueLines.isEmpty()) {
+			valueLines.add(escapedKey + "=");
+
+			sb.append(escapedKey);
+			sb.append("=");
+		}
+		else {
+			String value = valueLines.get(0);
+
+			String realValue = value;
+
+			if (!_typed) {
+				realValue = _escapeJava(value);
+			}
+
+			value = value.trim();
+
+			if (!value.startsWith(escapedKey)) {
+				valueLines.set(0, escapedKey + " = " + realValue);
+
+				sb.append(escapedKey);
+				sb.append(" = ");
+				sb.append(realValue);
+			}
+			else {
+				valueLines.set(0, realValue);
+				sb.append(realValue);
+			}
+		}
+
+		for (int i = 1; i < valueLines.size(); i++) {
+			String value = valueLines.get(i);
+
+			if (_typed) {
+				valueLines.set(i, value);
+			}
+			else {
+				valueLines.set(i, _escapeJava(value));
+			}
+
+			while ((value.length() > 0) &&
+				   Character.isWhitespace(value.charAt(0))) {
+
+				value = value.substring(1);
+			}
+
+			sb.append(value);
+		}
+
+		String[] property = PropertiesReader._parseProperty(sb.toString());
+
+		_layoutMap.put(key, new Layout(commentLines, valueLines));
+
+		return _storage.put(key, property[1]);
+	}
+
+	public String put(String key, List<String> commentLines, String value) {
+		commentLines = new ArrayList<>(commentLines);
+
+		_layoutMap.put(key, new Layout(commentLines, null));
+
+		return _storage.put(key, value);
+	}
+
+	@Override
+	public String put(String key, String value) {
+		String old = _storage.put(key, value);
+
+		if ((old == null) || !old.equals(value)) {
+			Layout layout = _layoutMap.get(key);
+
+			if (layout != null) {
+				layout.clearValue();
+			}
+		}
+
+		return old;
+	}
+
+	public String put(String key, String comment, String value) {
+		return put(key, Collections.singletonList(comment), value);
+	}
+
+	public void putAllSubstituted(Map<? extends String, ? extends String> map) {
+		_storage.putAll(map);
+	}
+
+	@Override
+	public String remove(Object key) {
+		Layout layout = _layoutMap.get(key);
+
+		if (layout != null) {
+			layout.clearValue();
+		}
+
+		return _storage.remove(key);
+	}
+
+	public void save() throws IOException {
+		save(_location);
+	}
+
+	public void save(File location) throws IOException {
+		try (OutputStream outputStream = new FileOutputStream(location)) {
+			save(outputStream);
+		}
+	}
+
+	public void save(OutputStream outputStream) throws IOException {
+		save(new OutputStreamWriter(outputStream, DEFAULT_ENCODING));
+	}
+
+	public void save(Writer writer) throws IOException {
+		saveLayout(writer, _typed);
+	}
+
+	/**
+	 * Set the comment footer.
+	 *
+	 * @param footer the footer to use
+	 */
+	public void setFooter(List<String> footer) {
+		_footer = footer;
+	}
+
+	/**
+	 * Set the comment header.
+	 *
+	 * @param header the header to use
+	 */
+	public void setHeader(List<String> header) {
+		_header = header;
+	}
+
+	/**
+	 * Calls the map method put. Provided for parallelism with the getProperty method.
+	 * Enforces use of strings for property keys and values. The value returned is the result of the map call to put.
+	 *
+	 * @param key the key to be placed into this property list.
+	 * @param value the value corresponding to the key.
+	 * @return the previous value of the specified key in this property list, or null if it did not have one.
+	 */
+	public Object setProperty(String key, String value) {
+		return put(key, value);
+	}
+
+	public void setTyped(boolean typed) {
+		_typed = typed;
+	}
+
+	/**
+	 * Store a properties into a output stream, preserving comments, special character, etc.
+	 * This method is mainly to be compatible with the java.util.Properties class.
+	 *
+	 * @param outputStream an output stream.
+	 * @param comment this parameter is ignored as this Properties
+	 * @throws IOException If storing fails
+	 */
+	public void store(OutputStream outputStream, String comment)
+		throws IOException {
+
+		save(outputStream);
+	}
+
+	public void substitute() {
+		substitute(_callback);
+	}
+
+	public void substitute(InterpolationHelper.SubstitutionCallback callback) {
+		if (callback == null) {
+			callback =
+				new InterpolationHelper.BundleContextSubstitutionCallback(null);
+		}
+
+		InterpolationHelper.performSubstitution(_storage, callback);
+	}
+
+	public boolean update(Map<String, String> props) {
+		Properties properties = new Properties();
+
+		if (props instanceof Properties) {
+			properties = (Properties)props;
+		}
+		else {
+			for (Map.Entry<? extends String, ? extends String> e :
+					props.entrySet()) {
+
+				properties.put(e.getKey(), e.getValue());
+			}
+		}
+
+		return update(properties);
+	}
+
+	public boolean update(Properties properties) {
+		boolean modified = false;
+
+		// Remove "removed" properties from the cfg file
+
+		for (String key : new ArrayList<>(keySet())) {
+			if (!properties.containsKey(key)) {
+				remove(key);
+
+				modified = true;
+			}
+		}
+
+		// Update existing keys
+
+		for (String key : properties.keySet()) {
+			String value = get(key);
+
+			List<String> comments = properties.getComments(key);
+
+			List<String> rawValue = properties.getRaw(key);
+
+			if (value == null) {
+				put(key, comments, rawValue);
+
+				modified = true;
+			}
+			else if (!value.equals(properties.get(key))) {
+				if (comments.isEmpty()) {
+					comments = getComments(key);
+				}
+
+				put(key, comments, rawValue);
+
+				modified = true;
+			}
+		}
+
+		return modified;
+	}
+
+	/**
+	 * This class is used to read properties lines. These lines do
+	 * not terminate with new-line chars but rather when there is no
+	 * backslash sign a the end of the line.  This is used to
+	 * concatenate multiple lines for readability.
+	 */
+	public static class PropertiesReader extends LineNumberReader {
+
+		/**
+		 * Creates a new instance of <code>PropertiesReader</code> and sets
+		 * the underlaying reader and the list delimiter.
+		 *
+		 * @param reader the reader
+		 */
+		public PropertiesReader(Reader reader, boolean maybeTyped) {
+			super(reader);
+
+			_maybeTyped = maybeTyped;
+		}
+
+		/**
+		 * Returns the comment lines that have been read for the last property.
+		 *
+		 * @return the comment lines for the last property returned by
+		 * <code>readProperty()</code>
+		 */
+		public List<String> getCommentLines() {
+			return _commentLines;
+		}
+
+		/**
+		 * Returns the name of the last read property. This method can be called
+		 * after <code>{@link #nextProperty()}</code> was invoked and its
+		 * return value was <b>true</b>.
+		 *
+		 * @return the name of the last read property
+		 */
+		public String getPropertyName() {
+			return _propertyName;
+		}
+
+		/**
+		 * Returns the value of the last read property. This method can be
+		 * called after <code>{@link #nextProperty()}</code> was invoked and
+		 * its return value was <b>true</b>.
+		 *
+		 * @return the value of the last read property
+		 */
+		public String getPropertyValue() {
+			return _propertyValue;
+		}
+
+		/**
+		 * Returns the value lines that have been read for the last property.
+		 *
+		 * @return the raw value lines for the last property returned by
+		 * <code>readProperty()</code>
+		 */
+		public List<String> getValueLines() {
+			return _valueLines;
+		}
+
+		public boolean isTyped() {
+			return _typed;
+		}
+
+		/**
+		 * Parses the next property from the input stream and stores the found
+		 * name and value in internal fields. These fields can be obtained using
+		 * the provided getter methods. The return value indicates whether EOF
+		 * was reached (<b>false</b>) or whether further properties are
+		 * available (<b>true</b>).
+		 *
+		 * @return a flag if further properties are available
+		 * @throws IOException if an error occurs
+		 */
+		public boolean nextProperty() throws IOException {
+			String line = readProperty();
+
+			if (line == null) {
+				return false; // EOF
+			}
+
+			// parse the line
+
+			String[] property = _parseProperty(line);
+
+			boolean typed = false;
+
+			if (_maybeTyped && (property[1].length() >= 2)) {
+				Matcher matcher = _pattern.matcher(property[1]);
+
+				typed = matcher.matches();
+			}
+
+			if ((_typed == null) || !_typed) {
+				_typed = typed;
+			}
+
+			_propertyName = _unescapeJava(property[0]);
+
+			_propertyValue = property[1];
+
+			return true;
+		}
+
+		/**
+		 * Reads a property line. Returns null if Stream is
+		 * at EOF. Concatenates lines ending with "\".
+		 * Skips lines beginning with "#" or "!" and empty lines.
+		 * The return value is a property definition (<code>&lt;name&gt;</code>
+		 * = <code>&lt;value&gt;</code>)
+		 *
+		 * @return A string containing a property value or null
+		 *
+		 * @throws IOException in case of an I/O error
+		 */
+		public String readProperty() throws IOException {
+			_commentLines.clear();
+			_valueLines.clear();
+
+			StringBuffer buffer = new StringBuffer();
+
+			while (true) {
+				String line = readLine();
+
+				if (line == null) {
+
+					// EOF
+
+					return null;
+				}
+
+				if (_isCommentLine(line)) {
+					_commentLines.add(line);
+
+					continue;
+				}
+
+				boolean combine = _checkCombineLines(line);
+
+				if (combine) {
+					line = line.substring(0, line.length() - 1);
+				}
+
+				_valueLines.add(line);
+
+				while ((line.length() > 0) &&
+					   contains(_WHITE_SPACE, line.charAt(0))) {
+
+					line = line.substring(1);
+				}
+
+				buffer.append(line);
+
+				if (!combine) {
+					break;
+				}
+			}
+
+			return buffer.toString();
+		}
+
+		/**
+		 * Checks if the passed in line should be combined with the following.
+		 * This is true, if the line ends with an odd number of backslashes.
+		 *
+		 * @param line the line
+		 * @return a flag if the lines should be combined
+		 */
+		private static boolean _checkCombineLines(String line) {
+			int bsCount = 0;
+
+			for (int i = line.length() - 1;
+				 (i >= 0) && (line.charAt(i) == '\\'); i--) {
+
+				bsCount++;
+			}
+
+			if ((bsCount % 2) != 0) {
+				return true;
+			}
+
+			return false;
+		}
+
+		/**
+		 * Parse a property line and return the key and the value in an array.
+		 *
+		 * @param line the line to parse
+		 * @return an array with the property's key and value
+		 */
+		private static String[] _parseProperty(String line) {
+
+			// sorry for this spaghetti code, please replace it as soon as
+			// possible with a regexp when the Java 1.3 requirement is dropped
+
+			String[] result = new String[2];
+
+			StringBuffer key = new StringBuffer();
+			StringBuffer value = new StringBuffer();
+
+			// state of the automaton:
+			// 0: key parsing
+			// 1: antislash found while parsing the key
+			// 2: separator crossing
+			// 3: white spaces
+			// 4: value parsing
+
+			int state = 0;
+
+			for (int pos = 0; pos < line.length(); pos++) {
+				char c = line.charAt(pos);
+
+				if (state == 0) {
+					if (c == '\\') {
+						state = 1;
+					}
+					else if (contains(_WHITE_SPACE, c)) {
+
+						// switch to the separator crossing state
+
+						state = 2;
+					}
+					else if (contains(_SEPARATORS, c)) {
+
+						// switch to the value parsing state
+
+						state = 3;
+					}
+					else {
+						key.append(c);
+					}
+				}
+				else if (state == 1) {
+					if (contains(_SEPARATORS, c) || contains(_WHITE_SPACE, c)) {
+
+						// this is an escaped separator or white space
+
+						key.append(c);
+					}
+					else {
+
+						// another escaped character, the '\' is preserved
+
+						key.append('\\');
+						key.append(c);
+					}
+
+					// return to the key parsing state
+
+					state = 0;
+				}
+				else if (state == 2) {
+					if (contains(_WHITE_SPACE, c)) {
+
+						// do nothing, eat all white spaces
+
+						state = 2;
+					}
+					else if (contains(_SEPARATORS, c)) {
+
+						// switch to the value parsing state
+
+						state = 3;
+					}
+					else {
+
+						// any other character indicates we encoutered the
+						// beginning of the value
+
+						value.append(c);
+
+						// switch to the value parsing state
+
+						state = 4;
+					}
+				}
+				else if (state == 3) {
+					if (contains(_WHITE_SPACE, c)) {
+
+						// do nothing, eat all white spaces
+
+						state = 3;
+					}
+					else {
+
+						// any other character indicates we encoutered the
+						// beginning of the value
+
+						value.append(c);
+
+						// switch to the value parsing state
+
+						state = 4;
+					}
+				}
+				else if (state == 4) {
+					value.append(c);
+				}
+			}
+
+			result[0] = key.toString();
+			result[1] = value.toString();
+
+			return result;
+		}
+
+		/** Stores the comment lines for the currently processed property.*/
+		private final List<String> _commentLines = new ArrayList<>();
+
+		private final boolean _maybeTyped;
+		private Pattern _pattern = Pattern.compile(
+			"\\s*[TILFDXSCBilfdxscb]?(\\[[\\S\\s]*\\]|\\{[\\S\\s]*\\}|" +
+				"\"[\\S\\s]*\")\\s*");
+
+		/** Stores the name of the last read property.*/
+		private String _propertyName;
+
+		/** Stores the value of the last read property.*/
+		private String _propertyValue;
+
+		/** Stores if the properties are typed or not */
+		private Boolean _typed;
+
+		/** Stores the value lines for the currently processed property.*/
+		private final List<String> _valueLines = new ArrayList<>();
+
+	}
+
+	/**
+	 * This class is used to write properties lines.
+	 */
+	public static class PropertiesWriter extends FilterWriter {
+
+		/**
+		 * Constructor.
+		 *
+		 * @param writer a Writer object providing the underlying stream
+		 */
+		public PropertiesWriter(Writer writer, boolean typed) {
+			super(writer);
+
+			_typed = typed;
+		}
+
+		/**
+		 * Helper method for writing a line with the platform specific line
+		 * ending.
+		 *
+		 * @param string the content of the line (may be <b>null</b>)
+		 * @throws IOException if an error occurs
+		 */
+		public void writeln(String string) throws IOException {
+			if (string != null) {
+				write(string);
+			}
+
+			write(_LINE_SEPARATOR);
+		}
+
+		/**
+		 * Writes the given property and its value.
+		 *
+		 * @param key the property key
+		 * @param value the property value
+		 * @throws IOException if an error occurs
+		 */
+		public void writeProperty(String key, String value) throws IOException {
+			write(_escapeKey(key));
+			write(" = ");
+			write(_typed ? value : _escapeJava(value));
+			writeln(null);
+		}
+
+		private boolean _typed;
+
+	}
+
+	/**
+	 * Writes the properties file to the given writer, preserving as much of its
+	 * structure as possible.
+	 *
+	 * @param writer the writer
+	 * @throws IOException if an error occurs
+	 */
+	protected void saveLayout(Writer writer, boolean typed) throws IOException {
+		try (PropertiesWriter propertiesWriter = new PropertiesWriter(
+				writer, typed)) {
+
+			if (_header != null) {
+				for (String s : _header) {
+					propertiesWriter.writeln(s);
+				}
+			}
+
+			for (Entry<String, String> entry : _storage.entrySet()) {
+				String key = entry.getKey();
+
+				String value = entry.getValue();
+
+				Layout layout = _layoutMap.get(key);
+
+				if (layout == null) {
+					propertiesWriter.writeProperty(key, value);
+
+					continue;
+				}
+
+				List<String> commentLines = layout.getCommentLines();
+
+				if (commentLines != null) {
+					for (String string : commentLines) {
+						propertiesWriter.writeln(string);
+					}
+				}
+
+				List<String> valueLines = layout.getValueLines();
+
+				if (valueLines == null) {
+					propertiesWriter.writeProperty(key, value);
+
+					continue;
+				}
+
+				int size = valueLines.size();
+
+				for (int i = 0; i < size; i++) {
+					String string = valueLines.get(i);
+
+					if (i < (size - 1)) {
+						propertiesWriter.writeln(string + "\\");
+					}
+					else {
+						propertiesWriter.writeln(string);
+					}
+				}
+			}
+
+			if (_footer != null) {
+				for (String string : _footer) {
+					propertiesWriter.writeln(string);
+				}
+			}
+		}
+	}
+
+	/**
+	 * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>
+	 *
+	 * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>
+	 *
+	 * <p>So a tab becomes the characters <code>'\\'</code> and
+	 * <code>'t'</code>.</p>
+	 *
+	 * <p>The only difference between Java strings and JavaScript strings
+	 * is that in JavaScript, a single quote must be escaped.</p>
+	 *
+	 * <p>Example:</p>
+	 * <pre>
+	 * input string: He didn't say, "Stop!"
+	 * output string: He didn't say, \"Stop!\"
+	 * </pre>
+	 *
+	 *
+	 * @param string  String to escape values in, may be null
+	 * @return String with escaped values, <code>null</code> if null string input
+	 */
+	private static String _escapeJava(String string) {
+		if (string == null) {
+			return null;
+		}
+
+		int length = string.length();
+
+		StringBuffer stringBuffer = new StringBuffer(length * 2);
+
+		for (int i = 0; i < length; i++) {
+			char c = string.charAt(i);
+
+			// handle unicode
+
+			if (c > 0xfff) {
+				stringBuffer.append("\\u");
+				stringBuffer.append(_hex(c));
+			}
+			else if (c > 0xff) {
+				stringBuffer.append("\\u0");
+				stringBuffer.append(_hex(c));
+			}
+			else if (c > 0x7f) {
+				stringBuffer.append("\\u00");
+				stringBuffer.append(_hex(c));
+			}
+			else if (c < 32) {
+				if (c == 'b') {
+					stringBuffer.append('\\');
+					stringBuffer.append('b');
+				}
+				else if (c == 'n') {
+					stringBuffer.append('\\');
+					stringBuffer.append('n');
+				}
+				else if (c == 't') {
+					stringBuffer.append('\\');
+					stringBuffer.append('t');
+				}
+				else if (c == 'f') {
+					stringBuffer.append('\\');
+					stringBuffer.append('f');
+				}
+				else if (c == 'r') {
+					stringBuffer.append('\\');
+					stringBuffer.append('r');
+				}
+				else {
+					if (c > 0xf) {
+						stringBuffer.append("\\u00");
+						stringBuffer.append(_hex(c));
+					}
+					else {
+						stringBuffer.append("\\u000");
+						stringBuffer.append(_hex(c));
+					}
+				}
+			}
+			else {
+				if (c == '"') {
+					stringBuffer.append('\\');
+					stringBuffer.append('"');
+				}
+				else if (c == '\\') {
+					stringBuffer.append('\\');
+					stringBuffer.append('\\');
+				}
+				else {
+					stringBuffer.append(c);
+				}
+			}
+		}
+
+		return stringBuffer.toString();
+	}
+
+	/**
+	 * Escape the separators in the key.
+	 *
+	 * @param key the key
+	 * @return the escaped key
+	 */
+	private static String _escapeKey(String key) {
+		StringBuffer stringBuffer = new StringBuffer();
+
+		for (int i = 0; i < key.length(); i++) {
+			char c = key.charAt(i);
+
+			if (contains(_SEPARATORS, c) || contains(_WHITE_SPACE, c)) {
+
+				// escape the separator
+
+				stringBuffer.append('\\');
+				stringBuffer.append(c);
+			}
+			else {
+				stringBuffer.append(c);
+			}
+		}
+
+		return stringBuffer.toString();
+	}
+
+	/**
+	 * <p>Returns an upper case hexadecimal <code>String</code> for the given
+	 * character.</p>
+	 *
+	 * @param ch The character to convert.
+	 * @return An upper case hexadecimal <code>String</code>
+	 */
+	private static String _hex(char ch) {
+		String hexString = Integer.toHexString(ch);
+
+		return hexString.toUpperCase(Locale.ENGLISH);
+	}
+
+	/**
+	 * Tests whether a line is a comment, i.e. whether it starts with a comment
+	 * character.
+	 *
+	 * @param line the line
+	 * @return a flag if this is a comment line
+	 */
+	private static boolean _isCommentLine(String line) {
+		String string = line.trim();
+
+		// blank lines are also treated as comment lines
+
+		if ((string.length() < 1) || (string.indexOf(_COMMENT_CHARS) == 0)) {
+			return true;
+		}
+
+		return false;
+	}
+
+	/**
+	 * <p>Unescapes any Java literals found in the <code>String</code> to a
+	 * <code>Writer</code>.</p> This is a slightly modified version of the
+	 * StringEscapeUtils.unescapeJava() function in commons-lang that doesn't
+	 * drop escaped separators (i.e '\,').
+	 *
+	 * @param string  the <code>String</code> to unescape, may be null
+	 * @return the processed string
+	 * @throws IllegalArgumentException if the Writer is <code>null</code>
+	 */
+	private static String _unescapeJava(String string) {
+		if (string == null) {
+			return null;
+		}
+
+		int size = string.length();
+
+		StringBuffer stringBuffer = new StringBuffer(size);
+
+		StringBuffer unicode = new StringBuffer(_UNICODE_LEN);
+
+		boolean hadSlash = false;
+
+		boolean inUnicode = false;
+
+		for (int i = 0; i < size; i++) {
+			char c = string.charAt(i);
+
+			if (inUnicode) {
+
+				// if in unicode, then we're reading unicode
+				// values in somehow
+
+				unicode.append(c);
+
+				if (unicode.length() == _UNICODE_LEN) {
+
+					// unicode now contains the four hex digits
+					// which represents our unicode character
+
+					try {
+						int value = Integer.parseInt(
+							unicode.toString(), _HEX_RADIX);
+
+						stringBuffer.append((char)value);
+
+						unicode.setLength(0);
+
+						inUnicode = false;
+
+						hadSlash = false;
+					}
+					catch (NumberFormatException numberFormatException) {
+						throw new IllegalArgumentException(
+							"Unable to parse unicode value: " + unicode,
+							numberFormatException);
+					}
+				}
+
+				continue;
+			}
+
+			if (hadSlash) {
+
+				// handle an escaped value
+
+				hadSlash = false;
+
+				if (c == '\\') {
+					stringBuffer.append("\\");
+				}
+				else if (c == '\'') {
+					stringBuffer.append('\'');
+				}
+				else if (c == '"') {
+					stringBuffer.append('"');
+				}
+				else if (c == 'r') {
+					stringBuffer.append('\r');
+				}
+				else if (c == 'f') {
+					stringBuffer.append('\f');
+				}
+				else if (c == 't') {
+					stringBuffer.append('\t');
+				}
+				else if (c == 'n') {
+					stringBuffer.append('\n');
+				}
+				else if (c == 'b') {
+					stringBuffer.append('\b');
+				}
+				else if (c == 'u') {
+					inUnicode = true;
+				}
+				else {
+					stringBuffer.append(c);
+				}
+
+				continue;
+			}
+			else if (c == '\\') {
+				hadSlash = true;
+
+				continue;
+			}
+
+			stringBuffer.append(c);
+		}
+
+		if (hadSlash) {
+
+			// then we're in the weird case of a \ at the end of the
+			// string, let's output it anyway.
+
+			stringBuffer.append('\\');
+		}
+
+		return stringBuffer.toString();
+	}
+
+	/**
+	 * Checks if parts of the passed in comment can be used as header comment.
+	 * This method checks whether a header comment can be defined (i.e. whether
+	 * this is the first comment in the loaded file). If this is the case, it is
+	 * searched for the lates blank line. This line will mark the end of the
+	 * header comment. The return value is the index of the first line in the
+	 * passed in list, which does not belong to the header comment.
+	 *
+	 * @param commentLines the comment lines
+	 * @return the index of the next line after the header comment
+	 */
+	private int _checkHeaderComment(List<String> commentLines) {
+		if ((getHeader() == null) && _layoutMap.isEmpty()) {
+
+			// This is the first comment. Search for blank lines.
+
+			int index = commentLines.size() - 1;
+
+			while (index >= 0) {
+				String commentLine = commentLines.get(index);
+
+				if (commentLine.length() <= 0) {
+					break;
+				}
+
+				index--;
+			}
+
+			setHeader(new ArrayList<>(commentLines.subList(0, index + 1)));
+
+			return index + 1;
+		}
+
+		return 0;
+	}
+
+	/** Constant for the supported comment characters.*/
+	private static final String _COMMENT_CHARS = "#!";
+
+	/** Constant for the radix of hex numbers.*/
+	private static final int _HEX_RADIX = 16;
+
+	/** Constant for the platform specific line separator.*/
+	private static final String _LINE_SEPARATOR = System.getProperty(
+		"line.separator");
+
+	/** The list of possible key/value separators */
+	private static final char[] _SEPARATORS = {'=', ':'};
+
+	/** Constant for the length of a unicode literal.*/
+	private static final int _UNICODE_LEN = 4;
+
+	/** The white space characters used as key/value separators. */
+	private static final char[] _WHITE_SPACE = {' ', '\t', '\f'};
+
+	private InterpolationHelper.SubstitutionCallback _callback;
+	private List<String> _footer;
+	private List<String> _header;
+	private final Map<String, Layout> _layoutMap = new LinkedHashMap<>();
+	private File _location;
+	private final Map<String, String> _storage = new LinkedHashMap<>();
+	private boolean _substitute = true;
+	private boolean _typed;
+
+	private static class Layout {
+
+		public Layout() {
+		}
+
+		public Layout(List<String> commentLines, List<String> valueLines) {
+			_commentLines = commentLines;
+			_valueLines = valueLines;
+		}
+
+		public void clearValue() {
+			_valueLines = null;
+		}
+
+		public List<String> getCommentLines() {
+			return _commentLines;
+		}
+
+		public List<String> getValueLines() {
+			return _valueLines;
+		}
+
+		public void setCommentLines(List<String> commentLines) {
+			_commentLines = commentLines;
+		}
+
+		public void setValueLines(List<String> valueLines) {
+			_valueLines = valueLines;
+		}
+
+		private List<String> _commentLines;
+		private List<String> _valueLines;
+
+	}
+
+	private class KeyIterator implements Iterator {
+
+		public KeyIterator() {
+			Set<Entry<String, String>> entries = _storage.entrySet();
+
+			_iterator = entries.iterator();
+		}
+
+		@Override
+		public boolean hasNext() {
+			return _iterator.hasNext();
+		}
+
+		@Override
+		public Entry<String, String> next() {
+			final Entry<String, String> entry = _iterator.next();
+
+			return new Entry<String, String>() {
+
+				@Override
+				public String getKey() {
+					return entry.getKey();
+				}
+
+				@Override
+				public String getValue() {
+					return entry.getValue();
+				}
+
+				@Override
+				public String setValue(String value) {
+					String old = entry.setValue(value);
+
+					if ((old == null) || !old.equals(value)) {
+						Layout layout = _layoutMap.get(entry.getKey());
+
+						if (layout != null) {
+							layout.clearValue();
+						}
+					}
+
+					return old;
+				}
+
+			};
+		}
+
+		@Override
+		public void remove() {
+			_iterator.remove();
+		}
+
+		private final Iterator<Entry<String, String>> _iterator;
+
+	}
 
 }
+/* @generated */
\ No newline at end of file
diff --git a/org/apache/felix/utils/properties/TypedProperties.java b/org/apache/felix/utils/properties/TypedProperties.java
index 8c0b27c..fe23179 100644
--- a/org/apache/felix/utils/properties/TypedProperties.java
+++ b/org/apache/felix/utils/properties/TypedProperties.java
@@ -6,7 +6,7 @@
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *	  http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -14,8 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.felix.utils.properties;
 
+import static org.apache.felix.utils.properties.InterpolationHelper.substVars;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -24,7 +27,9 @@ import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
+
 import java.net.URL;
+
 import java.util.AbstractMap;
 import java.util.AbstractSet;
 import java.util.Arrays;
@@ -36,8 +41,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import static org.apache.felix.utils.properties.InterpolationHelper.substVars;
-
 /**
  * <p>
  * Map to load / store / update untyped or typed properties.
@@ -51,409 +54,545 @@ import static org.apache.felix.utils.properties.InterpolationHelper.substVars;
  */
 public class TypedProperties extends AbstractMap<String, Object> {
 
-    public static final String ENV_PREFIX = "env:";
-
-    private final Properties storage;
-    private final SubstitutionCallback callback;
-    private final boolean substitute;
-
-    public TypedProperties() {
-        this(null, true);
-    }
-
-    public TypedProperties(boolean substitute) {
-        this(null, substitute);
-    }
-
-    public TypedProperties(SubstitutionCallback callback) {
-        this(callback, true);
-    }
-
-    public TypedProperties(SubstitutionCallback callback, boolean substitute) {
-        this.storage = new Properties(false);
-        this.callback = callback;
-        this.substitute = substitute;
-    }
-
-    public void load(File location) throws IOException {
-        InputStream is = new FileInputStream(location);
-        try {
-            load(is);
-        } finally {
-            is.close();
-        }
-    }
-
-    public void load(URL location) throws IOException {
-        InputStream is = location.openStream();
-        try {
-            load(is);
-        } finally {
-            is.close();
-        }
-    }
-
-    public void load(InputStream is) throws IOException {
-        load(new InputStreamReader(is, Properties.DEFAULT_ENCODING));
-    }
-
-    public void load(Reader reader) throws IOException {
-        storage.loadLayout(reader, true);
-        substitute(callback);
-    }
-
-    public void save(File location) throws IOException {
-        storage.save(location);
-    }
-
-    public void save(OutputStream os) throws IOException {
-        storage.save(os);
-    }
-
-    public void save(Writer writer) throws IOException {
-        storage.save(writer);
-    }
-
-    /**
-     * Store a properties into a output stream, preserving comments, special character, etc.
-     * This method is mainly to be compatible with the java.util.Properties class.
-     *
-     * @param os an output stream.
-     * @param comment this parameter is ignored as this Properties
-     * @throws IOException If storing fails
-     */
-    public void store(OutputStream os, String comment) throws IOException {
-        storage.store(os, comment);
-    }
-
-    @Override
-    public Set<Entry<String, Object>> entrySet() {
-        return new AbstractSet<Entry<String, Object>>() {
-            @Override
-            public Iterator<Entry<String, Object>> iterator() {
-                return new Iterator<Entry<String, Object>>() {
-                    final Iterator<String> keyIterator = storage.keySet().iterator();
-                    public boolean hasNext() {
-                        return keyIterator.hasNext();
-                    }
-                    public Entry<String, Object> next() {
-                        final String key = keyIterator.next();
-                        return new Entry<String, Object>() {
-                            public String getKey() {
-                                return key;
-                            }
-                            public Object getValue() {
-                                return TypedProperties.this.get(key);
-                            }
-                            public Object setValue(Object value) {
-                                return TypedProperties.this.put(key, value);
-                            }
-                        };
-                    }
-                    public void remove() {
-                        keyIterator.remove();
-                    }
-                };
-            }
-
-            @Override
-            public int size() {
-                return storage.size();
-            }
-        };
-    }
-
-    @Override
-    public Object put(String key, Object value) {
-        if (value instanceof String && !storage.typed) {
-            return storage.put(key, (String) value);
-        } else {
-            ensureTyped();
-            String old = storage.put(key, convertToString(value));
-            return old != null ? convertFromString(old) : null;
-        }
-    }
-
-    @Override
-    public Object get(Object key) {
-        String v = storage.get(key);
-        return storage.typed && v != null ? convertFromString(v) : v;
-    }
-
-    public Object put(String key, List<String> commentLines, Object value) {
-        if (value instanceof String && !storage.typed) {
-            return storage.put(key, commentLines, (String) value);
-        } else {
-            ensureTyped();
-            return put(key, commentLines, Arrays.asList(convertToString(value).split("\n")));
-        }
-    }
-
-    public Object put(String key, String comment, Object value) {
-        return put(key, Collections.singletonList(comment), value);
-    }
-
-    public Object put(String key, List<String> commentLines, List<String> valueLines) {
-        String old = storage.put(key, commentLines, valueLines);
-        return old != null ? storage.typed ? convertFromString(old) : old : null;
-    }
-
-    private void ensureTyped() {
-        if (!storage.typed) {
-            storage.typed = true;
-            Set<String> keys = new HashSet<String>(storage.keySet());
-            for (String key : keys) {
-                storage.put(key,
-                            storage.getComments(key),
-                            Arrays.asList(convertToString(storage.get(key)).split("\n")));
-            }
-        }
-    }
-
-    public boolean update(Map<String, Object> props) {
-        TypedProperties properties;
-        if (props instanceof TypedProperties) {
-            properties = (TypedProperties) props;
-        } else {
-            properties = new TypedProperties();
-            for (Entry<String, Object> e : props.entrySet()) {
-                properties.put(e.getKey(), e.getValue());
-            }
-        }
-        return update(properties);
-    }
-
-    public boolean update(TypedProperties properties) {
-        return storage.update(properties.storage);
-    }
-
-    public List<String> getRaw(String key) {
-        return storage.getRaw(key);
-    }
-
-    public List<String> getComments(String key) {
-        return storage.getComments(key);
-    }
-
-    @Override
-    public Object remove(Object key) {
-        return storage.remove(key);
-    }
-
-    @Override
-    public void clear() {
-        storage.clear();
-    }
-
-    /**
-     * Return the comment header.
-     *
-     * @return the comment header
-     */
-    public List<String> getHeader()
-    {
-        return storage.getHeader();
-    }
-
-    /**
-     * Set the comment header.
-     *
-     * @param header the header to use
-     */
-    public void setHeader(List<String> header)
-    {
-        storage.setHeader(header);
-    }
-
-    /**
-     * Return the comment footer.
-     *
-     * @return the comment footer
-     */
-    public List<String> getFooter()
-    {
-        return storage.getFooter();
-    }
-
-    /**
-     * Set the comment footer.
-     *
-     * @param footer the footer to use
-     */
-    public void setFooter(List<String> footer)
-    {
-        storage.setFooter(footer);
-    }
-
-    public void substitute(final SubstitutionCallback cb) {
-        if (!substitute) {
-            return;
-        }
-        final SubstitutionCallback callback = cb != null ? cb  : new SubstitutionCallback() {
-            public String getValue(String name, String key, String value) {
-                if (value.startsWith(ENV_PREFIX))
-                {
-                    return System.getenv(value.substring(ENV_PREFIX.length()));
-                }
-                else
-                {
-                    return System.getProperty(value);
-                }
-            }
-        }; //wrap(new BundleContextSubstitutionCallback(null));
-        Map<String, TypedProperties> props = Collections.singletonMap("root", this);
-        substitute(props, prepare(props), callback, true);
-    }
-
-    private static SubstitutionCallback wrap(final InterpolationHelper.SubstitutionCallback cb) {
-        return new SubstitutionCallback() {
-            public String getValue(String name, String key, String value) {
-                return cb.getValue(value);
-            }
-        };
-    }
-
-    public interface SubstitutionCallback {
-
-        String getValue(String name, String key, String value);
-
-    }
-
-    public static Map<String, Map<String, String>> prepare(Map<String, TypedProperties> properties) {
-        Map<String, Map<String, String>> dynamic = new HashMap<String, Map<String, String>>();
-        for (Map.Entry<String, TypedProperties> entry : properties.entrySet()) {
-            String name = entry.getKey();
-            dynamic.put(name, new DynamicMap(name, entry.getValue().storage));
-        }
-        return dynamic;
-    }
-
-    public static void substitute(Map<String, TypedProperties> properties,
-                                  Map<String, Map<String, String>> dynamic,
-                                  SubstitutionCallback callback,
-                                  boolean finalSubstitution) {
-        for (Map<String, String> map : dynamic.values()) {
-            ((DynamicMap) map).init(callback, finalSubstitution);
-        }
-        for (Map.Entry<String, TypedProperties> entry : properties.entrySet()) {
-            entry.getValue().storage.putAllSubstituted(dynamic.get(entry.getKey()));
-        }
-    }
-
-    private static String convertToString(Object value) {
-        try {
-            return ConfigurationHandler.write(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static Object convertFromString(String value) {
-        try {
-            return ConfigurationHandler.read(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static class DynamicMap extends AbstractMap<String, String> {
-        private final String name;
-        private final Properties storage;
-        private final Map<String, String> computed;
-        private final Map<String, String> cycles;
-        private SubstitutionCallback callback;
-        private boolean finalSubstitution;
-
-        public DynamicMap(String name, Properties storage) {
-            this.name = name;
-            this.storage = storage;
-            this.computed = new HashMap<String, String>();
-            this.cycles = new HashMap<String, String>();
-        }
-
-        public void init(SubstitutionCallback callback, boolean finalSubstitution) {
-            this.callback = callback;
-            this.finalSubstitution = finalSubstitution;
-        }
-
-        @Override
-        public Set<Entry<String, String>> entrySet() {
-            return new AbstractSet<Entry<String, String>>() {
-                @Override
-                public Iterator<Entry<String, String>> iterator() {
-                    final Iterator<String> iterator = storage.keySet().iterator();
-                    return new Iterator<Entry<String, String>>() {
-                        public boolean hasNext() {
-                            return iterator.hasNext();
-                        }
-                        public Entry<String, String> next() {
-                            final String key = iterator.next();
-                            return new Entry<String, String>() {
-                                public String getKey() {
-                                    return key;
-                                }
-                                public String getValue() {
-                                    String v = computed.get(key);
-                                    if (v == null) {
-                                        v = compute(key);
-//                                        computed.put(key, v);
-                                    }
-                                    return v;
-                                }
-                                public String setValue(String value) {
-                                    throw new UnsupportedOperationException();
-                                }
-                            };
-                        }
-                        public void remove() {
-                            throw new UnsupportedOperationException();
-                        }
-                    };
-                }
-
-                @Override
-                public int size() {
-                    return storage.size();
-                }
-            };
-        }
-
-        private String compute(final String key) {
-            InterpolationHelper.SubstitutionCallback wrapper = new InterpolationHelper.SubstitutionCallback() {
-                public String getValue(String value) {
-                    if (finalSubstitution) {
-                        String str = DynamicMap.this.get(value);
-                        if (str != null) {
-                            if (storage.typed) {
-                                boolean mult;
-                                boolean hasType;
-                                char t = str.charAt(0);
-                                if (t == '[' || t == '(') {
-                                    mult = true;
-                                    hasType = false;
-                                } else if (t == '"') {
-                                    mult = false;
-                                    hasType = false;
-                                } else {
-                                    t = str.charAt(1);
-                                    mult = t == '[' || t == '(';
-                                    hasType = true;
-                                }
-                                if (mult) {
-                                    throw new IllegalArgumentException("Can't substitute from a collection/array value: " + value);
-                                }
-                                return (String) convertFromString(hasType ? str.substring(1) : str);
-                            } else {
-                                return str;
-                            }
-                        }
-                    }
-                    return callback.getValue(name, key, value);
-                }
-            };
-            String value = storage.get(key);
-            String v = substVars(value, key, cycles, this, wrapper, false, finalSubstitution, finalSubstitution);
-            return v;
-        }
-    }
+	public static final String ENV_PREFIX = "env:";
+
+	public static Map<String, Map<String, String>> prepare(
+		Map<String, TypedProperties> properties) {
+
+		Map<String, Map<String, String>> dynamic = new HashMap<>();
+
+		for (Map.Entry<String, TypedProperties> entry : properties.entrySet()) {
+			String name = entry.getKey();
+
+			TypedProperties typedProperties = entry.getValue();
+
+			dynamic.put(name, new DynamicMap(name, typedProperties._storage));
+		}
+
+		return dynamic;
+	}
+
+	public static void substitute(
+		Map<String, TypedProperties> properties,
+		Map<String, Map<String, String>> dynamic, SubstitutionCallback callback,
+		boolean finalSubstitution) {
+
+		for (Map<String, String> map : dynamic.values()) {
+			DynamicMap dynamicMap = (DynamicMap)map;
+
+			dynamicMap.init(callback, finalSubstitution);
+		}
+
+		for (Map.Entry<String, TypedProperties> entry : properties.entrySet()) {
+			TypedProperties typedProperties = entry.getValue();
+
+			typedProperties._storage.putAllSubstituted(
+				dynamic.get(entry.getKey()));
+		}
+	}
+
+	public TypedProperties() {
+		this(null, true);
+	}
+
+	public TypedProperties(boolean substitute) {
+		this(null, substitute);
+	}
+
+	public TypedProperties(SubstitutionCallback callback) {
+		this(callback, true);
+	}
+
+	public TypedProperties(SubstitutionCallback callback, boolean substitute) {
+		_storage = new Properties(false);
+		_callback = callback;
+		_substitute = substitute;
+	}
+
+	@Override
+	public void clear() {
+		_storage.clear();
+	}
+
+	@Override
+	public Set<Entry<String, Object>> entrySet() {
+		return new AbstractSet<Entry<String, Object>>() {
+
+			@Override
+			public Iterator<Entry<String, Object>> iterator() {
+				return new KeyIterator();
+			}
+
+			@Override
+			public int size() {
+				return _storage.size();
+			}
+
+		};
+	}
+
+	@Override
+	public Object get(Object key) {
+		String value = _storage.get(key);
+
+		if ((value != null) && _storage.isTyped()) {
+			return _convertFromString(value);
+		}
+
+		return value;
+	}
+
+	public List<String> getComments(String key) {
+		return _storage.getComments(key);
+	}
+
+	/**
+	 * Return the comment footer.
+	 *
+	 * @return the comment footer
+	 */
+	public List<String> getFooter() {
+		return _storage.getFooter();
+	}
+
+	/**
+	 * Return the comment header.
+	 *
+	 * @return the comment header
+	 */
+	public List<String> getHeader() {
+		return _storage.getHeader();
+	}
+
+	public List<String> getRaw(String key) {
+		return _storage.getRaw(key);
+	}
+
+	public void load(File file) throws IOException {
+		try (InputStream inputStream = new FileInputStream(file)) {
+			load(inputStream);
+		}
+	}
+
+	public void load(InputStream inputStream) throws IOException {
+		try (InputStreamReader inputStreamReader = new InputStreamReader(
+				inputStream, Properties.DEFAULT_ENCODING)) {
+
+			load(inputStreamReader);
+		}
+	}
+
+	public void load(Reader reader) throws IOException {
+		_storage.loadLayout(reader, true);
+
+		substitute(_callback);
+	}
+
+	public void load(URL url) throws IOException {
+		try (InputStream inputStream = url.openStream()) {
+			load(inputStream);
+		}
+	}
+
+	public Object put(
+		String key, List<String> commentLines, List<String> valueLines) {
+
+		String old = _storage.put(key, commentLines, valueLines);
+
+		if (old == null) {
+			return null;
+		}
+
+		if (_storage.isTyped()) {
+			return _convertFromString(old);
+		}
+
+		return old;
+	}
+
+	public Object put(String key, List<String> commentLines, Object value) {
+		if ((value instanceof String) && !_storage.isTyped()) {
+			return _storage.put(key, commentLines, (String)value);
+		}
+
+		_ensureTyped();
+
+		String string = _convertToString(value);
+
+		return put(key, commentLines, Arrays.asList(string.split("\n")));
+	}
+
+	@Override
+	public Object put(String key, Object value) {
+		if ((value instanceof String) && !_storage.isEmpty()) {
+			return _storage.put(key, (String)value);
+		}
+
+		_ensureTyped();
+
+		String old = _storage.put(key, _convertToString(value));
+
+		if (old == null) {
+			return null;
+		}
+
+		return _convertFromString(old);
+	}
+
+	public Object put(String key, String comment, Object value) {
+		return put(key, Collections.singletonList(comment), value);
+	}
+
+	@Override
+	public Object remove(Object key) {
+		return _storage.remove(key);
+	}
+
+	public void save(File location) throws IOException {
+		_storage.save(location);
+	}
+
+	public void save(OutputStream outputStream) throws IOException {
+		_storage.save(outputStream);
+	}
+
+	public void save(Writer writer) throws IOException {
+		_storage.save(writer);
+	}
+
+	/**
+	 * Set the comment footer.
+	 *
+	 * @param footer the footer to use
+	 */
+	public void setFooter(List<String> footer) {
+		_storage.setFooter(footer);
+	}
+
+	/**
+	 * Set the comment header.
+	 *
+	 * @param header the header to use
+	 */
+	public void setHeader(List<String> header) {
+		_storage.setHeader(header);
+	}
+
+	/**
+	 * Store a properties into a output stream, preserving comments, special character, etc.
+	 * This method is mainly to be compatible with the java.util.Properties class.
+	 *
+	 * @param outputStream an output stream.
+	 * @param comment this parameter is ignored as this Properties
+	 * @throws IOException If storing fails
+	 */
+	public void store(OutputStream outputStream, String comment)
+		throws IOException {
+
+		_storage.store(outputStream, comment);
+	}
+
+	public void substitute(final SubstitutionCallback substitutionCallback) {
+		if (!_substitute) {
+			return;
+		}
+
+		SubstitutionCallback callback = substitutionCallback;
+
+		if (callback == null) {
+			callback = new SubstitutionCallback() {
+
+				@Override
+				public String getValue(String name, String key, String value) {
+					if (value.startsWith(ENV_PREFIX)) {
+						return System.getenv(
+							value.substring(ENV_PREFIX.length()));
+					}
+
+					return System.getProperty(value);
+				}
+
+			};
+		}
+
+		Map<String, TypedProperties> map = Collections.singletonMap(
+			"root", this);
+
+		substitute(map, prepare(map), callback, true);
+	}
+
+	public boolean update(Map<String, Object> map) {
+		TypedProperties typedProperties = new TypedProperties();
+
+		if (map instanceof TypedProperties) {
+			typedProperties = (TypedProperties)map;
+		}
+		else {
+			for (Entry<String, Object> entry : map.entrySet()) {
+				typedProperties.put(entry.getKey(), entry.getValue());
+			}
+		}
+
+		return update(typedProperties);
+	}
+
+	public boolean update(TypedProperties properties) {
+		return _storage.update(properties._storage);
+	}
+
+	public interface SubstitutionCallback {
+
+		public String getValue(String name, String key, String value);
+
+	}
+
+	private static Object _convertFromString(String value) {
+		try {
+			return ConfigurationHandler.read(value);
+		}
+		catch (IOException ioException) {
+			throw new RuntimeException(ioException);
+		}
+	}
+
+	private static String _convertToString(Object value) {
+		try {
+			return ConfigurationHandler.write(value);
+		}
+		catch (IOException ioException) {
+			throw new RuntimeException(ioException);
+		}
+	}
+
+	private static SubstitutionCallback _wrap(
+		final InterpolationHelper.SubstitutionCallback cb) {
+
+		return new SubstitutionCallback() {
+
+			@Override
+			public String getValue(String name, String key, String value) {
+				return cb.getValue(value);
+			}
+
+		};
+	}
+
+	private void _ensureTyped() {
+		if (!_storage.isTyped()) {
+			_storage.setTyped(true);
+
+			Set<String> keys = new HashSet<>(_storage.keySet());
+
+			for (String key : keys) {
+				String string = _convertToString(_storage.get(key));
+
+				_storage.put(
+					key, _storage.getComments(key),
+					Arrays.asList(string.split("\n")));
+			}
+		}
+	}
+
+	private final SubstitutionCallback _callback;
+	private final Properties _storage;
+	private final boolean _substitute;
+
+	private static class DynamicMap extends AbstractMap<String, String> {
+
+		public DynamicMap(String name, Properties storage) {
+			_name = name;
+			_storage = storage;
+		}
+
+		@Override
+		public Set<Entry<String, String>> entrySet() {
+			return new AbstractSet<Entry<String, String>>() {
+
+				@Override
+				public Iterator<Entry<String, String>> iterator() {
+					Set<String> keys = _storage.keySet();
+
+					return new ComputedIterator(keys.iterator());
+				}
+
+				@Override
+				public int size() {
+					return _storage.size();
+				}
+
+			};
+		}
+
+		public void init(
+			SubstitutionCallback callback, boolean finalSubstitution) {
+
+			_callback = callback;
+			_finalSubstitution = finalSubstitution;
+		}
+
+		private String _compute(final String key) {
+			InterpolationHelper.SubstitutionCallback wrapper =
+				new InterpolationHelper.SubstitutionCallback() {
+
+					@Override
+					public String getValue(String value) {
+						String string = DynamicMap.this.get(value);
+
+						if (!_finalSubstitution || (string == null)) {
+							return _callback.getValue(_name, key, value);
+						}
+
+						if (!_storage.isTyped()) {
+							return string;
+						}
+
+						boolean mult = false;
+
+						boolean hasType = false;
+
+						char t = string.charAt(0);
+
+						if ((t == '[') || (t == '(')) {
+							mult = true;
+						}
+						else {
+							t = string.charAt(1);
+
+							if ((t == '[') || (t == '(')) {
+								mult = true;
+							}
+
+							hasType = true;
+						}
+
+						if (mult) {
+							throw new IllegalArgumentException(
+								"Cannot substitute from a collection/array " +
+									"value: " + value);
+						}
+
+						if (hasType) {
+							return (String)_convertFromString(
+								string.substring(1));
+						}
+
+						return (String)_convertFromString(string);
+					}
+
+				};
+
+			String value = _storage.get(key);
+
+			return substVars(
+				value, key, _cycles, this, wrapper, false, _finalSubstitution,
+				_finalSubstitution);
+		}
+
+		private SubstitutionCallback _callback;
+		private final Map<String, String> _computed = new HashMap<>();
+		private final Map<String, String> _cycles = new HashMap<>();
+		private boolean _finalSubstitution;
+		private final String _name;
+		private final Properties _storage;
+
+		private class ComputedIterator
+			implements Iterator<Entry<String, String>> {
+
+			public ComputedIterator(Iterator<String> iterator) {
+				_iterator = iterator;
+			}
+
+			@Override
+			public boolean hasNext() {
+				return _iterator.hasNext();
+			}
+
+			@Override
+			public Entry<String, String> next() {
+				String key = _iterator.next();
+
+				return new Entry<String, String>() {
+
+					@Override
+					public String getKey() {
+						return key;
+					}
+
+					@Override
+					public String getValue() {
+						String v = _computed.get(key);
+
+						if (v == null) {
+							v = _compute(key);
+						}
+
+						return v;
+					}
+
+					@Override
+					public String setValue(String value) {
+						throw new UnsupportedOperationException();
+					}
+
+				};
+			}
+
+			@Override
+			public void remove() {
+				throw new UnsupportedOperationException();
+			}
+
+			private final Iterator<String> _iterator;
+
+		}
+
+	}
+
+	private class KeyIterator implements Iterator {
+
+		public KeyIterator() {
+			Set<String> entries = _storage.keySet();
+
+			_iterator = entries.iterator();
+		}
+
+		@Override
+		public boolean hasNext() {
+			return _iterator.hasNext();
+		}
+
+		@Override
+		public Entry<String, Object> next() {
+			String key = _iterator.next();
+
+			return new Entry<String, Object>() {
+
+				@Override
+				public String getKey() {
+					return key;
+				}
+
+				@Override
+				public Object getValue() {
+					return TypedProperties.this.get(key);
+				}
+
+				@Override
+				public Object setValue(Object value) {
+					return TypedProperties.this.put(key, value);
+				}
+
+			};
+		}
+
+		@Override
+		public void remove() {
+			_iterator.remove();
+		}
+
+		private final Iterator<String> _iterator;
+
+	}
+
 }
+/* @generated */
\ No newline at end of file
